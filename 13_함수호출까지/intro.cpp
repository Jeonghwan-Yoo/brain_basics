/*
스택 세그먼트와 스택 프레임은 어떻게 다른가요?
스택 세그먼트란 프로그램에서 사용하기 편하도록 메모리를 용도 나누 것 중 하나.
스택 프레임(stack frame)은 함수가 호출될 때마다 그 함수 호출을 위해 할당 받는 메모리 덩어리.
스택 프레임은 스택 세그먼트에 잡히게 됩니다.

스택 프레임을 사용해서 얻는 이점은 무엇인가요?
C프로그램은 함수의 호출 과정이라고 말할 수 있습니다.
main이라는 함수에서 시작해서 차례대로 다른 함수를 불러가며 프로그램이 진행됩니다.
함수 호출 시 가장 중요한 이슈가 복귀 주소와 인자의 전달인데 레지스터나 메모리의 특정 주소를 사용하면
중첩 호출이 불가능해집니다.
반면 스택 프레임을 사용하면 매번 함수가 호출될 때마다 스택 프레임이 구성되므로 전달 및 복귀주소를
스택프레임을 통해 전달하고, 중첩되어 호출되더라도 호출 때마다 별도의 스택 프레임을 구성하므로
스택 크기만 충분하다면 얼마든지 중첩 호출이 가능합니다.

01 벽돌과도 같은 함수 - 구조화된 프로그래밍
C에서 함수라는 것은 사실 구조화된(Structured) 프로그래밍 언어에서 '프로시저(Procedure)' 및
'함수(Function)'개념을 모두 포함하는 것.
프로그램 안에서 자주쓰이는 기능을 프로시저라는 별도의 코드로 작성해 놓고 필요한 곳에서 프로시저를 부르는 것.
C에서는 프로시저를 별도로 두지 않고 함수의 리턴값이 없는 void를 허용함으로써 대신하고 있습니다.
함수는 호출의 결과값이 있다는 점에서 다릅니다.
함수를 잘 활용하면 자주 반복되는 코드를 묶어서 코드의 효율성을 높일 수 있습니다.
내부구조는 잊어도 입력과 출력 관계에 대해서만 기억함으로써 복잡한 프로그램을 만들 수 있습니다.
함수는 인자를 넘겨받고 결과값을 리턴할 수도 있습니다.
함수가 효율적인 것은 자주 쓰이는 루틴을 함수라는 이름으로 추상해두고(입출력만 기억하고 내부는 몰라도됨)
필요한 곳에서 그 함수를 '호출'해서 사용할 수 있기 때문.
함수를 부르는 지점에서 함수의 코드가 삽입되는 것이 아니라 함수의 코드가 있는 곳으로 점프하기 때문.

서브루틴
따로 서용되지 않고 메인루틴과 결합하여 기능을 수행하며 특정 기능을 반복 수행해야 할 때 주로 이용.
CPU입장에선 jmp를 통해 제어권이 함수의 코드가 있는 메모리 주소로 넘어간다는 것을 의미.
함수의 중요한 요소는 함수 루틴으로 점프하여 수행이 끝난 후 점프 인스트럭션이 호출된 지점으로 복귀해야한다.
즉, 함수를 호출할 때는 인자값을 함수에게 넘겨 함수가 그 인자에 대해 적절한 동작을 할 수 있도록 해야하며,
발생한 결과값을 다시 호출한 코드에서 활용할 수 있도록 다시 넘겨 받아야 합니다.
그리고 함수의 호출은 중첩 가능해야 합니다.
중첩은 함수 안에서 다시 함수를 부를 수 있는 것.
재귀호출은 호출되는 함수가 호출하는 함수랑 동일한 것.
정리해보면
1)호출 지점으로 복귀 가능해야 한다.
2)호출하는 코드(Caller) 호출되는 함수(Callee) 간에 데이터 교환을 할 수 있어야 한다. 인자를 넘기고 리턴값.
3)함수 안에서 자기 자신을 포함해 어떤 함수든 부를 수 있도록 중첩적이어야 한다.
이런 기능을 지원하기 위해 스택이라는 자료구조를 사용.

02 함수호출의 기본 원리 - 스택 프레임
어셈블리는 소규모의 임베디드 시스템에서 많이 사용되는데 특별히 하드웨어를 제어하거나 효율성높은 코드를 작성할 때.
어셈블리로 서브루틴을 구현하려면 메모리를 복사하는 루틴을 만들고 복사할 시작 주소와 타겟 주소,
그리고 복사할 양을 서브루틴에 전달할 것입니다.
그리고 이 루틴이 끝난 후에 다시 호출된 지점에서 돌아와 하던 작업을 실행.
또한 CPU가 가지고 있는 범용 레지스터 중 일부를 인자 전달 혹은 리턴값을 받는 용도로 할애.
레지스터가 부족할 수도 있고 호출하는 쪽에서도 레지스터를 사용하지 않는다는 보장이 없다.
서브루틴은 자기를 호출한 시점에서 어떤 레지스터가 사용중인지도 알 수가 없다.
그렇기 때문에 이런 방식은 효율적이지 못한다.
그래서 스택 프레임(Stack Frame)을 사용.
스택 프레임이란 함수가 호출될 때마다 그 함수 호출을 위해 할당받는 메모리 덩어리. 스택 세그먼트에 있다.
jmp를 쓰면 코드는 고정된 메모리 주소에 존재하기 때문에 컴파일러가 함수 호출이 발생할 때마다 그 주소를
계산해서 만들어 줄 수 는 있지만 함수에서 호출 코드로 되돌아갈 때는 이 주소가 고정되어 있지 않다.
그래서 CPU에선 호출을 지원해주기 위해 특별한 레지스터를 마련하고 이 레지스터에 리턴 주소를 보관하는 방식.
그리고 CPU는 단순히 주어진 주소값으로만 점프하는 jmp와 별도의 인스트럭션을 제공. call이라고 하자.
CPU는 call을 만나면 call과 함께 주어진 주소로 점프합니다.
이 때 call인스트럭션 바로 다음 주소를 특정한 레지스터에 저장하게 됩니다.
그리고 CPU에서는 ret이라는 함수 복귀 인스트럭션을 별도로 제공합니다.
ret인스트럭션은 call때 저장한 특정한 레지스터 값으로 점프하는 것.
call인스트럭션패치 |   ...     |
        1. 0x234_/|call 0x555 | ──┬─> 2. CPU는 레지스터에 call다음 주소인 0x235를 저장. RX=0x235 복귀주소.
		┌───────> | add r1,r2 |   |
		|		  |   ...     |   | 3. 0x555번지로 점프
		|  0x555_/| mul r3,r5 | <─┘ 4. 함수 코드시작 주소에서 함수 수행
		|		  |   ...     |
	    └─────────|   ret     | 5. ret인스트럭션 패치
     6. call할 때 저장된 RX레지스터의 값 0x234로 번지로 점프
물론 굳이 call이나 ret인스트럭션이 없어도 PC레지스터만 읽을 수 있다면 원하는 레지스터어 PC레지스터값을
저장하고 jmp인스트럭션으로 원하는 함수 코드로 점프하고 마지막엔 복귀주소로 다시 점프하면 됩니다.
하지만 함수호출을 중요하고 빈번히 일어나기 때문에 별도의 인스트럭션이 있는 것.
PC값을 저장하고 다시 jmp하는 두가지 작업을 한 인스트럭션에 끝낼 수 있어 성능 향상에 도움.

그래도 중첩 호출이 불가능합니다.
왜냐면 call인스트럭션을 통해 다른 함수를 호출하면 복귀 주소를 다시 RX레지스터에 저장할텐데
이미 저장된 주소가 있어 기존 주소를 다른 레지스터나 메모리에 보관하고 호출해야 합니다.
그리고 호출한 함수가 리턴하면 다시 RX레지스터에 원래 값을 복구해 놓아야 합니다.
개수가 많아지면 혼돈이오고 절대주소로 메모리에 저장하면 레지스터처럼 다를 바가 없다.
즉, 중첩 호출되면 같은 메모리 주소에 값을 쓰게 되고, 이전 값이 사라지는 것.
이를 위해서 스택프레임사용.
복귀 주소를 쌓아둔 메모리 중 가장 윗부분 주소를 특정 레지스터에 저장해두도록 약속합니다.
이 레지스터를 SP라고 부릅니다.
main함수도 어디선가 호출이 된 함수고 끝날 때 복귀해야 할 주소가 있기 때문에 
스택 시작주소 SP는 0x888을 가리키고 xxx라는 main가 마친 후에 복귀 주소가 저장.
|      |
|      |
|      |
|  xxx |\_SP=0x888
프로그램이 시작되고 종료될 때 프로그램에서 사용할 힙이나 스택에 대한 할당 및 초기화라든지 프로그램이
시작될 때 전달받은 인자들을 main함수로 전달하기 위한 작업이든지 여러작업을 수행한 다음에 main함수가 불림.
main함수가 리턴한 후에도 프로그램을 정상적으로 종료시키기 위한 마무리 작업 역시 필요.
따라서 프로그램이 시작되는 지점은 소스코드상엔 없지만 컴파일러가 별도로 만들어 놓고 main을 호출.
그리고 main함수가 끝나고 난 후의 복귀 주소가 스택에 저장되어야 하는 것.
main복귀 주소위에 그 다음 함수가 저장되고 SP가 4바이트만큼 조정되어 가리킴.
|      |
| 0x100|\_SP=0x880. func2
| 0x400|            func1
|  xxx |            main
func2함수가 마치고 리턴하면 제일 위에 저장되어있는 다음 주소로 프로그램이 수행됩니다.
그리고 다시 4바이트만큼 SP값을 조정해줘야 합니다. 그리고 func1은 그대로 수행.
|      |
|      |
| 0x400|\_SP=0x884. func1
|  xxx |            main
이런 식이라면 함수가 중첩이 되거나 재귀호출이어도 복귀 주소가 항상 스택의 제일 꼭대기에 저장되고
SP레지스터로 값을 액세스 할 수 있으므로 문제없이 호출된 지점으로 복귀할 수 있습니다.
스택 프레임이라는 것은 함수의 복귀 주소를 나타냅니다.
함수를 호출할 때 꼭 필요한 데이터가 바로 복귀주소였고 4바이트 단위로 이루어진 복귀주소 하나하나가
각각의 함수 호출에 대한 스택 프레임이 되는 것.

03 스택 프레임을 통한 함수간 값 전달
함수 호출할 때 가장 필수적인 것이 복귀주소지만 Caller와 Callee의 데이터 교환도 가능해야 합니다.
일반적인 함수는 인자로 어떤 값을 전달하고 처리를 하여 결과를 다시 리턴해줌.
인자를 전달하고 다시 결과값을 리턴받는 용도로도 스택 프레임이 활용됩니다.
인자전달까지 하는 경우 함수 호출 시 복귀 주소 바로 다음에 차곡차곡 저장하고 복귀주소와 저장된 인자만큼
SP를 조정해주고 호출받은 함수 측에서는 다시 이 SP를 사용하여 해당 값을 액세스해 인자교환이 일어남.
void func1(int a) {
	func2(1,2);
	//0x100
	return;
}
void func2(char x, char y) {
	return;
}
main() {
	func1(5);
	//0x400
}
func1이 호출되기 전까지는 스택에는 main함수의 복귀 주소만 저장되어 있습니다.
|      |
| 0x400|\_SP=0x880. func1
|   5  |
|  xxx |            main
복귀주소인 0x400이외에도 func1에 전달하는 인자값 5도 스택에 같이 저장.
SP는 주소값 크기 4바이트와 int형 인자크기 4바이트를 더해 8바이트만큼 조정됨.
func2가 호출되면 func2가 복귀할 주소와 인자값 1,2가 스택에 저장되고 다시 그만큼 SP조정.
func2의 인자는 모두 char이므로 2바이트만 차지하기 때문에 복귀주소까지 총 6바이트를 조정해줘야하지만
이렇게 1바이트나 2바이트처럼 SP를 조절하려면 CPU에서 지원해줘야합니다.
SP는 일반적으로 그 값을 직접조정할 수 없고 push나 pop으로 대표되는 인스트럭션을 통해
스택에 데이터를 저장하거나 빼오면서 자동으로 조절.
그런데 이런 인스트럭션은 CPU의 처리단위 32비트라면 4바이트 단위로 스택에 데이터를 저장하기 때문에
1바이트 단위로 push,pop이 지원되지 않으면 그렇게 조절할 수 없습니다.
CPU가 허용한다해도 성능적인 면에서 딱 정해진 크기만큼 할당하고 해제하는것(정렬)이 훨씬 효율적.
따라서 컴파일러가 의도적으로 위와 같은 경우도 int와 동일한 크기로 char변수를 생성합니다.
|      |
| 0x100|\_SP=0x874. func2
|   1  |            
|   2  |
| 0x400|            func1
|   5  |
|  xxx |            main
Callee에서 액세스하는 것도 SP를 이용해서 간단히 읽어올 수 있습니다.
func2가 전달받은 1과 2라는 인자값을 액세스하고 싶으면 SP+4,SP+8한 곳의 값을 읽어오면 되는 것.
func2가 마치고 리턴할 때는 바로 SP가 가리키는 0x100번지로 점프하면 된다.
즉, SP는 항상 스택의 제일 끝을 가리키며 이 주소를 기준으로 복귀주소와 인자값이 저장되니 얼마든지 액세스가능.

리턴하는 경우에는 CPU나 컴파일러마다 다를 수 있지만 대부분의 경우 스택프레임이 아닌 레지스터를 이용한다.
전달하는 인자와는 달리 리턴값을 하나로 고정되어 있기 때문에 주로 특정 레지스터를 통해 전달.
PC에서는 주로 EAX라는 레지스터를 통해 넘깁니다. 실수인 경우는 실수 연산용 별도 레지스터가 있다.
호출받은 함수가 리턴하기 바로 직전에 EAX레지스터에 리턴하고자 하는 값을 저장하고, 호출이 끝나게 되면
EAX레지스터에 리턴값이 있는 걸로 간주하고 다음 처리를 해 나갑니다.
예를 들어 int sum(int a, int b)같은 함수에서 리턴값이 a와 b의 합이라면 sum내부에서는 가장 마지막에
a+b값을 eax레지스터에 저장하고, sum함수를 호출한 곳에서는 sum함수의 호출 바로 다음부터
eax레지스터의 값으로 원하는 작업을 하는 것.

int sum(int a, int b) {
	return a + b;
}
void printResult(int c) {
	printf("10 + 20 = %d", c);
}
int main(int argc, char* argv[]) {
	printResult(sum(10, 20));

	return 1;
}
int main(int argc, char* argv[]) {
001F1800 55                   push        ebp
001F1801 8B EC                mov         ebp,esp
001F1803 81 EC C0 00 00 00    sub         esp,0C0h
001F1809 53                   push        ebx
001F180A 56                   push        esi
001F180B 57                   push        edi
001F180C 8D BD 40 FF FF FF    lea         edi,[ebp-0C0h]
001F1812 B9 30 00 00 00       mov         ecx,30h
001F1817 B8 CC CC CC CC       mov         eax,0CCCCCCCCh
001F181C F3 AB                rep stos    dword ptr es:[edi]
001F181E B9 03 C0 1F 00       mov         ecx,offset _16111C6B_test.c (01FC003h)
001F1823 E8 EA F9 FF FF       call        @__CheckForDebuggerJustMyCode@4 (01F1212h)
	printResult(sum(10, 20));
001F1828 6A 14                push        14h
001F182A 6A 0A                push        0Ah
001F182C E8 A1 F8 FF FF       call        _sum (01F10D2h)
001F1831 83 C4 08             add         esp,8
001F1834 50                   push        eax
001F1835 E8 0A FA FF FF       call        _printResult (01F1244h)
001F183A 83 C4 04             add         esp,4
	return 1;
001F183D B8 01 00 00 00       mov         eax,1
}
제일먼저 sum함수를 호출합니다. 이 때 인자값으로 10과 20 두개의 int값을 전달해야 합니다.
두 인자는 함수가 호출되기 전에 스택에 저장해야 호출된 함수에서 SP를 통해 액세스 할 수 있습니다.
push라는 인스트럭션을 통해  14h(20)과 0Ah(=10)을 스택에 저장하고 있습니다.
push인스트럭션은 주어진 값을 스택의 제일 끝에 저장하고 SP값을 4바이트만큼 감소시킵니다.
왜냐면 큰 주소에서부터 시작해서 작은 주소 쪽으로 쌓여가도록 되어 있으므로.
call이라는 인스트럭션을 통해 sum함수를 호출합니다.
call인스트럭션은 주어진 주소대로 점프하되 스택에 현재 PC레지스터의 값(다음 클럭에 수행할 주소)를 저장.
push와 마찬가지로 스택에 저장하므로 스택 포인터 레지스터를 4바이트만큼 감소합니다.
CPU에서는 SP로 ESP라는 레지스터가 사용됩니다.
| 001F1831 |\_ESP
| 0x0A(10) |
| 0x14(20) |
디버깅에서 call 인스트럭션을 수행해봅니다.
ESP값을 보거나 레지스터창을 띄어 ESP의 값을 확인해봅니다.
008FF960의 값이 ESP의 값이고 실제 메모리를 띄어 살펴보면
0x008FF95C  31 18 1f 00 //sum함수가 복귀할 주소. call바로 다음 주소
0x008FF960  0a 00 00 00 //sum인자값
0x008FF964  14 00 00 00 //sum인자값
스택의 제일 끝에는 sum함수가 복귀할 주소값이 기록되어 있고 그 뒤로 인자값 10과 20이 16진수로 나타남.
call인스트럭션의 수행이 끝난 후에는 sum함수를 호출하기 이전과 동일해야 합니다.
함수를 호출하기 이전의 상태로 스택을 돌려놓아야 한다는 것.
add esp,8은 할당된 스택을 끝에서 8바이트만큼 줄인다는 의미.
두 인자와 복귀주소를 합쳐 12바이트를 줄여야했었는데 sum내에서 복귀할 때 미리 복귀 주소 4바이트
만큼을 스택에서 해제하여 4바이트만큼 증가시켰다.
따라서 sum함수 호출 이후에 호출한 측에서는 복귀 주소 4바이트를 제외하고 전체 인자 크기 8바이트만큼 ESP조정.
sum 호출 직후| 001F1831 |\_ESP  sum 호출 끝난 후 | 001F1831 |      add esp,8   | 001F1831 | 
 --------->	| 0x0A(10) |        -------------> | 0x0A(10) |\_ESP ----------> | 0x0A(10) |
			| 0x14(20) |                       | 0x14(20) |                  | 0x14(20) |    
ESP보다 위쪽에 있는 값은 메모리엔 남아 있지만 더이상 참조되지 않는 값이므로 쓰레기값이다.       \_ESP
																						 
이 이유는 호출규약(Calling Convention)의 표준의 문제.
그 중 함수를 선언할 때 특별히 명시하지 않으면 __cdel이라고 부르는 C의 기본 함수호출규약을 따르며
기본적으로 인자가 차지하는 스택을 해지하는 책임을 호출한 측에 있습니다.
즉, sum함수에 전달한 인자 값 8바이트를 스택에서 해지하는 것은 호출한 측에서 add esp,8을 행하는 것.
__stdcall은 인자에 대한 스택 해지까지 호출된 함수 내부에서 하며, 호출한 측에서는 별도의 작업을
할 필요가 없어 함수의 독립성이 뛰어나다는 장점이 있습니다.
add esp,8같은 코드가 함수가 호출할 때마다 필요없으므로 코드크기도 작아짐.
이런 콜링 컨벤션은 함수를 선언할 때 함수의 리턴값과 이름 사이에 컨벤션 타입을 적어 결정할 수 있다.
sum함수를 __cdel이 아닌 __stdcall로 바꾸려면 
int __stdcall sum(int a, int b) {
	return a + b;
}
__stdcall키워드를 삽입하고 재컴파일 하면 __stdcall 규약을 따르도록 코드가 생성. 실제 내부동작이 달라짐.
속도를 더 높이기 위해 두 개의 파라미터까지는 메모리를 사용하지 않고 레지스터를 사용해서 전달하는
__fastcall이라는 호출규약도 있습니다.
2개 까지는 ecs와 edx라는 레지스터를 통해 전달하고 그 이상의 인자에 대해서는 __stdcall과 똑같이.
push 14h, push0Ah대신에 mov edx,14h, mov ecx,0Ah로 edx와ecx 레지스터에 인자값을 넣고 있습니다.
sum내부에서는 이 두 레지스터를 통해 인자값을 얻는 것.
3번째 인자부터는 push를 통해 스택에 저장.

다음은 sum함수의 호출 결과를 얻어와 printResult인자로 넘겨주는 것.
리턴값은 스택이 아닌 레지스터를 통해 전달된다고 했다. eax.
call sum인스트럭션을 수행한 직후에 eax레지스터를 확인해보면 10+20인 30이 들어가 있습니다.
sum함수를 호출할 때와 마찬가지로 eax레지스터의 값을 스택에 저장합니다.
그래서 호출이 끝난 후 바로 push eax실행하고 call로 printResult.
특별히 호출 규약을 지정하지 않았으므로 __cdel형태로 컴파일되어 인자에 대한 해지를 호출한 측에서 합니다.
add esp,4

그리고 마지막에는 return 1하는 코드는 mov eax,1로 컴파일되어 있습니다.
즉, main도 하나의 함수일 뿐이고 리턴값을 eax레지스터 저장하는 것.

int sum(int a, int b) {
 push        ebp
 mov         ebp,esp
 sub         esp,0C0h
 push        ebx
 push        esi
 push        edi
 lea         edi,[ebp+FFFFFF40h]
 mov         ecx,30h
 mov         eax,0CCCCCCCCh
 rep stos    dword ptr es:[edi]
 mov         ecx,93C003h
 call        00931212
	return a + b;
 mov         eax,dword ptr [ebp+8]
 add         eax,dword ptr [ebp+0Ch]
}
 pop         edi
 pop         esi
 pop         ebx
 add         esp,0C0h
 cmp         ebp,esp
 call        0093121C
 mov         esp,ebp
 pop         ebp
 ret
sum함수에서도 main과 같이 push ebp, mov ebp,esp가 가장 먼저 나옵니다.
ebp레지스터를 스택에 저장하고 다시 이 ebp레지스터에 esp레지스터의 내용을 복사하는 것.
마지막 두 번째 줄 보면 pop ebp가 있습니다.
pop은 push의 반대의 일을 하는데 스택의 제일 끝에서 4바이트만큼 데이터를 꺼내와 지정된 레지스터에 저장.
그리고 스택포인터를 스택이 줄어드는 방향으로 4바이트만큼 조정합니다.
여기서는 ebp레지스터에 스택 끝에 있는 값을 가져오는 셈.
스택 끝에 있는 값은 push ebp로 저장했던 원래 ebp레지스터에 있던 값.
이 값은 함수와는 상관없이 함수 호출 이전에 결정되어 있던 값.
함수 가장 첫 머리에 ebp레지스터를 저장하므로 함수 내부에서는 그대로 저장했다가 함수가 끝날 때 돌려놈.
따라서 이 함수를 호출하는 입장에서는 호출 전이나 후에 ebp레지스터에 변화는 없다.
코드 중간에 ebp+8같은 형태를 사용하고 있는데 호출측에서 스택에 저장한 인자값을 액세스하기 위해서.
이미 ebp레지스터엔 esp를 그대로 복사해 놓았기 때문에 esp대신 ebp를 사용해 액세스할 수 있습니다.
push ebp 직후
| 원래 ebp레지스터 값 |\_esp=ebp
| sum함수의 복귀 주소 |
|      0x0A(10)      |\_첫번째 인자 a=[ebp+8]
|      0x14(20)      |\_두번째 인자 b=[ebp+12]
sum함수를 호출하기 이전에 20,10,복귀 주소 순으로 스택에 저장했고 sum함수 내부에서 제일먼저
push ebp로 ebp값을 저장했다.
두 인자의 합은
mov eax,dword ptr [ebp+8]
add eax,dword ptr [ebp+0Ch]
ebp+8번지의 값(a)를 eax레지스터로 옮겨와 ebp+12번지의 값(b)이랑 더합니다.
그리고 덧셈 결과는 다시 eax레지스터에 저장됩니다. 리턴값은 eax레지스터.
sum함수는 ebp레지스터를 복구하고(pop ebp) 함수에서 ret인스트럭션으로 리턴.
ret은 스택의 제일 끝에 있는 값을 복귀 주소로 삼아 그 주소로 점프하고 동시에 esp값을 4바이트만큼
스택을 줄이는 방향으로 조정합니다.
복귀 주소는 원래 ebp값 바로 다음에 있었는데, ret바로 이전에 pop으로 원래 ebp값을 해지하였으므로
스택 제일 끝에는 복귀주소가 있는 셈.
ebp레지스터는 esp대신 인자값을 액세스하기 위해 사용된 것 밖에 없습니다.
esp를 사용하지 않고 ebp를 사용한 이유는 컴파일러의 편의성을 위해서입니다.
esp는 코드 중간에 push나 pop으로 수시로 변할 여지가 있습니다.
push가 중간에 있으면 그 이전과 이후에 esp를 기준으로 액세스할 때 상대적인 오프셋 값이 변하는 문제.
컴파일러에 따라 일일이 다 고려해 오프셋값을 생성하는 경우도 있지만 ebp 같은 별도의 레지스터에
초반 esp값을 복사해놓고 이후 ebp레지스터의 값을 기준으로 스택을 액세스하면 esp가 아무리 변해도
고정된 오프셋 값으로 스택을 액세스할 수 있습니다.
그러면 코드를 생성하는 입장과 개발자 입장에서는 이해하기 더 쉽다.
그래서 VC++컴파일러는 스택프레임을 구성하면서 ebp레지스터에 esp값을 옮겨와 사용하되 caller측에서도
같은 방식으로 ebp레지스터를 사용하고 있으므로 호출받은 함수 내부에서 미리 ebp레지스터 값을 스택에
보관했다가 함수가 리턴하기 바로 직전에 이를 복구합니다.
그렇기 때문에 호출한 측에서는 여전히 같은 ebp값으로 작업을 계속할 수 있는 것.
main함수도 ebp레지스터를 스택에 보관하고 esp값을 복사한 후 마지막에 다시 ebp를 복구하는 작업을 그대로.
물론 main함수 내에서는 ebp레지스터를 통해 인자를 액세스하는 부분이 없습니다.
그래서 쓸데없이 코드 낭비하는 것을 컴파일러는 최적화 과정을 통해 불필요한 코드를 제거하기도 합니다.

04 지역변수
스택프레임이라는 것이 지역변수를 위해서도 중요하게 사용됨.
함수는 어디서 불릴지 모를는 것이고, 하나의 모듈로서 독립성을 가지고 동작해야 합니다.
함수 내부에서 전역 변수를 사용하게 되면 독립성이 떨어지므로 좋은방법이 아니다.
함수는 재귀호출뿐 아니라 여러 형태로 해당 함수가 끝나기 전에 다시 함수가 호출되는(재진입) 경우가
종종 발생할 수 있으므로 대비책이 필요합니다.
즉, 함수가 중첩되어도 앞 뒤 작업간의 독립성을 유지할 방법.
전형적인 방법이 매 함수 호출 때마다 함수 내부에서 사용하는 변수 전부를 메모리에 새로 할당받는 방법.
아무리 함수가 중복되어 호출되도 함수마다 서로 다른 메모리에서 작업하므로 독립성을 유지할 수 있다.
스택 프레임은 인자의 전달 뿐아니라 지역 변수의 할당을 위해서도 최적의 구조를 제공합니다.
#include <stdio.h>
int triple_sum(int a, int b) {
	int nTripleA = a * 3;
	int nTripleB = b * 3;

	return nTripleA + nTripleB;
}
void printResult(int c) {
	printf("(10*3) + (20*3) = %d", c);
}
int main(int argc, char* argv[]) {
	printResult(triple_sum(10, 20));
	return 1;
}
sum함수 내부에 두 개의 변수를 만들고 3씩 곱해 두 수의 합을 리턴합니다.
triple_sum함수만 확인해보면
int triple_sum(int a, int b) {
00D81970 55                   push        ebp
00D81971 8B EC                mov         ebp,esp
00D81973 81 EC D8 00 00 00    sub         esp,0D8h //지역변수 두 int변수 크기만큼 스택을 늘림.
00D81979 53                   push        ebx
00D8197A 56                   push        esi
00D8197B 57                   push        edi
00D8197C 8D BD 28 FF FF FF    lea         edi,[ebp+FFFFFF28h]
00D81982 B9 36 00 00 00       mov         ecx,36h
00D81987 B8 CC CC CC CC       mov         eax,0CCCCCCCCh
00D8198C F3 AB                rep stos    dword ptr es:[edi]
00D8198E B9 03 C0 D8 00       mov         ecx,0D8C003h
00D81993 E8 7A F8 FF FF       call        00D81212
	int nTripleA = a * 3;
00D81998 6B 45 08 03          imul        eax,dword ptr [ebp+8],3
00D8199C 89 45 F8             mov         dword ptr [ebp-8],eax
	int nTripleB = b * 3;
00D8199F 6B 45 0C 03          imul        eax,dword ptr [ebp+0Ch],3
00D819A3 89 45 EC             mov         dword ptr [ebp-14h],eax

	return nTripleA + nTripleB;
00D819A6 8B 45 F8             mov         eax,dword ptr [ebp-8]
00D819A9 03 45 EC             add         eax,dword ptr [ebp-14h]
}
00D819AC 5F                   pop         edi
00D819AD 5E                   pop         esi
00D819AE 5B                   pop         ebx
00D819AF 81 C4 D8 00 00 00    add         esp,0D8h
00D819B5 3B EC                cmp         ebp,esp
00D819B7 E8 60 F8 FF FF       call        00D8121C
00D819BC 8B E5                mov         esp,ebp
00D819BE 5D                   pop         ebp
00D819BF C3                   ret
ebp레지스터를 스택에 저장하고 esp레지스터를 복사하는 부분은 동일.
직접 뺄셈을 하는 sub와 esp레지스터를 줄이는 부분을 봐보자.
PC에서의 스택은 메모리의 뒤 쪽, 주소가 큰부분에서 작은부분(메모리 앞쪽)으로 커지는 모양.
따라서 esp를 줄인다는 것은 스택을 키운다는 것과 같습니다.
그리고 늘어난 공간이 함수 내에 선언된 두 개의 지역 변수를 위해 할당된 공간.
컴파일러는 이미 컴파일하면서 triple_sum함수 내에 두 개의 int지역변수가 사용된다는 사실을
알고 있고, 스택 공간을 두 변수에 할당하기 위해 esp를 강제로 조정한 것.
sub코드가 수행되고 난 직후의 스택 모습
   ESP_/| nTripleB 위한 공간 |\_nTripleB=[ebp-8]
		| nTripleA 위한 공간 |\_nTripleA=[ebp-4]
   EBP_/| 원래 ebp레지스터 값 |
		|      복귀 주소     |
		|      0x0A(10)      |\_a=[ebp+8]
		|      0x14(20)      |\_b=[ebp+12]
이전 예제들과 다르게 esp와 ebp레지스터의 값이 다르다.
왜냐하면 ebp레지스터에 esp레지스터를 복사하고 난 이후에 esp를 강제로 8바이트만큼 조정한 것이기 때문.
esp를 ebp에 복사한 이유는 지금처럼 sp가 변하게 되면 그때마다 액세스하고자 하는 곳에 오프셋 값이 변하기 때문.
esp는 모든 스택 인스트럭션이 기준으로 삼는 sp레지스터므로 항상 스택의 끝을 가리킨다.
즉 esp레지스터가 가리키고 있는 곳이 스택의 끝이다.
esp는 다른 필요한 공간을 스택에 다 할당한 후에 지역변수를 위해 조정되었으므로 이후 triple_sum함수가
리턴하기 전에 중간에 다른 함수가 호출되도 항상 esp를 기준으로 그 위에 스택프레임이 구성되므로
지역 변수를 위한 공간은 침범 받지 않는 것.
그리고 이 공간은 ebp레지스터를 기준으로 마이너스 오프셋 값을 가지고 액세스할 수 있습니다.
a가 위치한 곳에서 이 값을 eax레지스터로 옮겨와 3을 곱해 다시 eax에 대입하게 됩니다.
그리고 결과값을 다시 ebp-8(nTripleA를 위한 공간)에 옮깁니다.
mov esp,ebp는 esp에 다시 ebp를 넣어주는 코드인데, 함수 내부에서 사용했던 지역변수용 스택을 해지하는 부분.
이를 통해 그전에 함수와 같은 형태로 함수의 리턴 준비를 할 수 있는 것.
pop ebp로 기존 ebp값을 복원시키고 ret으로 스택의 제일 윗 부분에 있게된 복귀주소를 참조해 호출코드로 돌아감.
호출측에서는 다시 esp값을 조정해 인자를 위한 스택 부분을 해지할 것.
스택 프레임에 지역 변수를 위한 공간을 마련하면, 함수 중첩이 되도 결국 현재 스택 위에 또 다른 스택 프레임이
구성되고 그 안에 새로운 지역 변수 공간이 확보되기 때문에 이전 변수값에 대해선 영향을 미치지 않습니다.

호출규약
인자를 위해 확보한 스택공간을 누가 해지해주는가에대한 부분에 대한 정의. Caller냐 Callee냐.
스택 공간의 해지는 add esp,8같이 강제로 조정하는 코드를 삽입함으로써 이루어집니다.
C에서는 기본적으로 __cdel형으로 함수가 선언되고 따라서 저런 해지 코드가 호출한 측, 즉 함수를 call하고 
그 다음에 삽입합니다.
프로그램은 함수호출이 많이 있기 때문에 해지코드가 추가되면 코드 크기도 커지고 어셈블리로 코딩한다면
서브루틴 호출 때마다 전달 인자 크기를 계산하여 코드를 삽입해야 합니다.
__stdcall형으로 선언한 함수에서는 해지코드가 함수 내부에 리턴하기 바로 직전에 들어있습니다.
그러기 때문에 해지 코드는 하나로 족한 것이고 사이즈로 컴팩트해집니다.
함수내부에서 처리하고 외부에서는 신경을 쓰지 않아도되서 함수의 독립성을 높일 수 있습니다.
근데도 __cdel이 있는 이유는 __stdcall은 처음부터 C에 존재하는 형이 아니었습니다.
이는 파스칼에서 사용되던 호출규약이었는데 회사마다 서로 다른 규약을 사용했던 것.
C에서는 __stdcall을 사용할 수 없었던 이유가 있는데 가변인자라는 것 때문입니다.
함수를 선언할 때는 인자수와 형을 명시적으로 기록했었지만
printf가 가변 인자를 사용하는 대표적인 함수인데 무한히 많은 인자를 계속 넣을 수 있었습니다.
int __cdel printf(const char*, ...);
...은 인자가 개수에 상관없이 받아 들일 수 있는 가변인자.
함수의 프로토타입이라는 것은 컴파일러가 문법적으로 체크하기 위한 것이지 번역되면 중요한게 아니다.
호출 시 기재된 개수만큼 스택에 저장하고 호출하면 되는 것이니까.
문제는 함수 수행이 끝나고 인자부분을 스택에서 해지할 때 일어납니다.
__cdel형으로 선언된 함수이면 해지를 호출한 곳에서 매번 해주므로 printf함수를 부를 때마다 개수가 달라도 괜찮.
printf가 호출된 곳마다 add esp,xx해지코드가 들어가고 사용된 인자개수만큼 컴파일러가 알아서 xx를 결정하기 때문.
__stdcall로 선언된 경우는 인자 해지 코드가 함수 내부로 들어가야 하는데 가변 인자가 사용되는 경우
몇 개의 인자가 전달되었는지 함수 내부에서는 알 방법이 없기 때문.
획일적으로 add esp,8처럼 정해진 상수값으로 SP레지스터를 조정할 수 없으므로 __stdcall로는 가변인자가 불가능.
int __stdcall testfunc(int a, int b) {
00951752 B9 30 00 00 00       mov         ecx,30h
00951757 B8 CC CC CC CC       mov         eax,0CCCCCCCCh
0095175C F3 AB                rep stos    dword ptr es:[edi]
0095175E B9 03 B0 95 00       mov         ecx,95B003h
00951763 E8 9B FA FF FF       call        00951203
	return a + b;
00951768 8B 45 08             mov         eax,dword ptr [ebp+8]
0095176B 03 45 0C             add         eax,dword ptr [ebp+0Ch]
}
0095176E 5F                   pop         edi
0095176F 5E                   pop         esi
00951770 5B                   pop         ebx
00951771 81 C4 C0 00 00 00    add         esp,0C0h
00951777 3B EC                cmp         ebp,esp
00951779 E8 8F FA FF FF       call        0095120D
0095177E 8B E5                mov         esp,ebp
00951780 5D                   pop         ebp
00951781 C2 08 00             ret         8
int main(int argc, char* argv[]) {
009516E0 55                   push        ebp
009516E1 8B EC                mov         ebp,esp
009516E3 81 EC C0 00 00 00    sub         esp,0C0h
009516E9 53                   push        ebx
009516EA 56                   push        esi
009516EB 57                   push        edi
009516EC 8D BD 40 FF FF FF    lea         edi,[ebp+FFFFFF40h]
009516F2 B9 30 00 00 00       mov         ecx,30h
009516F7 B8 CC CC CC CC       mov         eax,0CCCCCCCCh
009516FC F3 AB                rep stos    dword ptr es:[edi]
009516FE B9 03 B0 95 00       mov         ecx,95B003h
00951703 E8 FB FA FF FF       call        00951203
	testfunc(10, 20);
00951708 6A 14                push        14h
0095170A 6A 0A                push        0Ah
0095170C E8 85 F9 FF FF       call        00951096
	return 1;
00951711 B8 01 00 00 00       mov         eax,1
}
00951716 5F                   pop         edi
00951717 5E                   pop         esi
00951718 5B                   pop         ebx
00951719 81 C4 C0 00 00 00    add         esp,0C0h
0095171F 3B EC                cmp         ebp,esp
00951721 E8 E7 FA FF FF       call        0095120D
00951726 8B E5                mov         esp,ebp
00951728 5D                   pop         ebp
00951729 C3                   ret
main에선 call이후에 add esp,8같은 코드가 없습니다.
testfunc에선 ret에 8이라는 숫자와 함께 부릅니다.
ret을 그냥 부르면 단순히 스택의 제일 위에서 복귀 주소를 읽어 점프하고 SP레지스터를 4바이트만큼
조정할 뿐이지만 저렇게 인자가 있는 경우 그 크기만큼 SP레지스터를 추가로 조정합니다.
즉 add esp,8하는 것과 동일한 효과가 있는 셈.
int __stdcall testfunc(int a, int b, ...) {
0113175E B9 03 B0 13 01       mov         ecx,113B003h
01131763 E8 9B FA FF FF       call        01131203
	return a + b;
01131768 8B 45 08             mov         eax,dword ptr [ebp+8]
0113176B 03 45 0C             add         eax,dword ptr [ebp+0Ch]
}
0113176E 5F                   pop         edi
0113176F 5E                   pop         esi
01131770 5B                   pop         ebx
01131771 81 C4 C0 00 00 00    add         esp,0C0h
01131777 3B EC                cmp         ebp,esp
01131779 E8 8F FA FF FF       call        0113120D
0113177E 8B E5                mov         esp,ebp
01131780 5D                   pop         ebp
01131781 C3                   ret
int main(int argc, char* argv[]) {
011316E0 55                   push        ebp
011316E1 8B EC                mov         ebp,esp
011316E3 81 EC C0 00 00 00    sub         esp,0C0h
011316E9 53                   push        ebx
011316EA 56                   push        esi
011316EB 57                   push        edi
011316EC 8D BD 40 FF FF FF    lea         edi,[ebp+FFFFFF40h]
011316F2 B9 30 00 00 00       mov         ecx,30h
011316F7 B8 CC CC CC CC       mov         eax,0CCCCCCCCh
011316FC F3 AB                rep stos    dword ptr es:[edi]
011316FE B9 03 B0 13 01       mov         ecx,113B003h
01131703 E8 FB FA FF FF       call        01131203
	testfunc(10, 20, 30);
01131708 6A 1E                push        1Eh
0113170A 6A 14                push        14h
0113170C 6A 0A                push        0Ah
0113170E E8 5D FC FF FF       call        01131370
01131713 83 C4 0C             add         esp,0Ch
	return 1;
01131716 B8 01 00 00 00       mov         eax,1
}
0113171B 5F                   pop         edi
0113171C 5E                   pop         esi
0113171D 5B                   pop         ebx
0113171E 81 C4 C0 00 00 00    add         esp,0C0h
01131724 3B EC                cmp         ebp,esp
01131726 E8 E2 FA FF FF       call        0113120D
0113172B 8B E5                mov         esp,ebp
0113172D 5D                   pop         ebp
0113172E C3                   ret
가변 인자를 추가해보면 push가 3번나오고 testfunc을 call합니다.
__stdcall로 선언했음에도 불구하고 add esp,0Ch라는 코드가 있습니다.
이 코드는 3개의 인자크기 12바이트만큼 esp를 조정해 인자부분에 대한 공간을 스택에서 해지하는 코드.
testfunc자체를 살펴보면 __cdel로 선언된 함수처럼 되어 있습니다.
실제 함수를 선언할 때는 __stdcall로 선언했지만 가변인자가 사용되어서
___stdcall형태론 구현할 수 없으므로 컴파일러가 강제로 __cdel로 코드를 생성한 것.
__fastcall은 최대 두 개까지의 인자는 메모리 액세스를 하지 않고 바로 레지스터로 전달하게 하여
더욱 속도를 높이고자 만들어진 호출 규약.
ecx,edx를 사용해 전달되므로 레지스터에 비해 훨씬 느린 메모리액세스를 하지 않아도 된다는 장점.
CPU에 따라 여분의 레지스터가 없을 수도 있으며, 컴파일러가 레지스터를 어떻게 활용하냐에 따라
구현이 불가능할 수도 있으므로 모든 컴파일러가 지원하지는 않습니다.
윈도우에서 사용하는 API라이브러리 등은 모두 __stdcall형태의 호출규약을 사용해 만들어져있다.
따라서 C컴파일러에서 선언된 윈도우즈 API함수들의 헤더는 모두 WINAPI라는 키워드를 포함하고 있습니다.
WINAPI키워드는 __stdcall을 #define을 사용해 재정의 해놓은 것 뿐이다.

*/