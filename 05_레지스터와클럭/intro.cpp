/*
레지스터(Register)란 무엇일까요?
CPU가 동작하면서 필요한 정보를 일시적으로 저장해 두는 일종의 메모리입니다.
CPU 계산하면서 중간중간 현재의 상태 값을 기억하기 위해 아주 빠른 기억 장치가 필요한데 이를 레지스터

클럭(Clock)은 무엇일까요?
CPU도 정해진 시간에 주어진 동작을 하도록 설계되어 있습니다.
특히 CPU를 구성하는 컴포넌트 중 현재 상태값을 기억하는 레지스터가 있습니다.
레지스터는 플립플롭으로 이루어져 있는데 클럭 신호가 있어야만 기억하고 있는 값을 갱신하게 됩니다.

01 ALU와 메모리
ALU는 컨트롤 입력을 어떻게 주냐에 따라 연산을 선택할 수 있는 범용적인 모듈.
ALU라는 것은 진공관 시절을 지나 IC에 기반해서 만들어진 디지털 서킷이고 
이 시절엔 찰떡 궁합인 소자가 있습니다. 바로 기억소자 메모리입니다.

02 컴퓨터의 곱셈과 레지스터
2진수의 곱셈에서 승수에 1이 있으면 그 자리는 피승수를 그대로 가져오고, 0이 있으면 그냥 0인 두 가지 경우.
조건문에 가깝기 때문에 AND게이트를 사용해 승수와 피승수의 각 자리를 게이트에 넣어주면 결과를 구현할 수 있다.
각 승수 자리마다 곱셈 결과물을 모두 더해야 합니다.
그 결과물을 다시 다른 숫자와 더해가는 과정을 거쳐야 한다는 것.
ALU역시 한 번 덧셈한 결과를 기억했다가 이를 다시 입력으로 넣어서 또다른 값과 덧셈해야 하는 것.
곱셈을 하기위해 중간 과정을 저장하기 위한 메모리가 필요합니다.
다시 절차적으로 봐보면 승수와 피승수 모두 4비트씩 이루어져 있다고하면 최대 8비트까지입니다.
이 결과를 수용하기 위해선 8비트의 메모리가 필요합니다.
ALU의 덧셈의 결과가 8비트 필요합니다.
입력도 8비트로 이루어집니다.
승수의 제일 마지막 비트부터 시작해 차례대로 한 비트씩 왼쪽으로 올라가면서 피승수와 곱하여
그 결과값을 더한 것이 최종 결과.
그 중간 결과값들은 곱해진 승수의 자릿수만큼 뒤에 0이 붙어 더해집니다.
이를 위해선 승수와 피승수를 위한 메모리도 필요합니다.
승수의 제일 마지막 비트부터 매 단계마다 왼쪽으로 자릿수를 옮겨가는 것은 승수를 저장하고 있는 메모리를
매 단계마다 한 비트씩 오른쪽으로 쉬프트해 항상 제일 마지막 비트를 피승수에 곱해주면 됩니다.
곱해진 중간 결과 뒤에 승수의 쉬프트 된 횟수만큼 0을 붙이는 과정은 매 단계에서 승수를 쉬프트할 때마다
피승수를 왼쪽으로 쉬프트하여 이 값을 오른쪽 쉬프트한 피승수의 마지막 비트와 곱해주면 됩니다.
이렇게 매 단계마다 승수와 피승수를 쉬프트하기 위해서는 이 값들을 메모리에 저장해야 합니다.
곱셈을 위해서 ALU이외에도 승수와 피승수, 결과값을 저장할 3개의 8비트 메모리가 필요한 것.
이러한 메모리는 ALU에 직접 연결되어 연산의 주체가 되는 메모리로서 연산 과정을 기억하는 메모리라는 
의미로 레지스터라고 부릅니다.
승수와 피승수를 저장하는 레지스터는 한 비트씩 쉬프트해야 하므로 특별히 쉬프트 레지스터라고 합니다.

2x1 MUX <-8비트 피승수 레지스터(왼쪽쉬프트)
     |  <-8비트 승수 레지스터(오른쪽쉬프트)
	 v
 ┌>8비트 ALU(ADD)
 |   |
 |	 v
 └8비트 결과값 레지스터
매 단계마다 승수와 피승수 레지스터는 각각 오른쪽, 왼쪽으로 1비트씩 쉬프트하고 승수 레지스터의
마지막 비트에 의해 ALU에 들어가는 입력값이 0또는 쉬프트한 피승수 값으로 결정되어 기존의 결과값과 합쳐져
다시 결과값 레지스터에 저장됩니다.
이 알고리즘은 실제 곱셈 알고리즘에 쓰이진 않습니다.
단점이 많아 이것들을 개선한 방식의 곱셈 알고리즘을 사용합니다.
CPU에서는 명령어를 처리하기 위한 과정을 절차적으로 나누어 아주 효율적인 형태로 동작하고 있으며
이러한 과정에서 가장 필수적인 요소가 바로 레지스터.
매 절차마다의 결과를 보관하고 이를 적절히 다음 절차에서 활용하는 형태.
따라서 대부분의 CPU명령어(Instruction)은 레지스터를 기반으로 활용하는 형태로 구성.

03 컴퓨터의 시계 - 클럭
순차회로는 플립플롭이라는 메모리 소자로 구성된 회로를 일컬었습니다.
레지스터도 플립플롭으로 이루어져 있습니다.
게이트와 플립플롭의 차이는 바로 '클럭(Clock)'의 유무.
플립플롭은 입력단이 어떻게 바뀌더라도 '클럭'펄스가 들어오기 전에는 출력단에 아무 변화가 없었다.
출력값은 클럭 펄스가 들어오는 순간 그 때의 입력값에 의해 출력값이 변경되고 다음클럭까지 유지합니다.
플립플롭을 메모리 소자라고 합니다.
레지스터들도 마찬가지로 클럭이 인가될 때만 출력값을 변경할 수 있습니다.
     |2
	 v      4
 ┌>8비트 ALU-ADD
 |1  |3
 |	 v
 └8비트 결과값 레지스터
ALU는 조합회로이므로 클럭이 필요없습니다. 입력값이 바뀌면 곧바로 그 결과가 출력에 반영되는 것.
1이나2의값이 바뀌게 되면 컨트롤 입력이 ADD이므로 바로 3도 1+2의 값으로 바뀌게 됩니다.
만일 컨트롤입력인 4가 ADD에서 SUB나 AND같이 다른 명령으로 바뀌면 곧바로 3이 해당 연산종류에 따라 변경됨.
결과 레지스터는 플립플롭으로 구성된 순차회로이므로 클럭이 필요합니다.
레지스터입력값인 3이 변하더라도 출력값인 1은 바로 변하지 않습니다.
처음시작은 2가 변하자마자 ALU의 결과값인 3도 바로 변합니다.
클럭이 인가되지 않으면 1은 여전히 원래 상태를 유지하고 3도 안정된 값으로 존재합니다.
클럭이 인가되면 변경된 3값에 따라 레지스터 출력인 1이 다시 변화되고 바로 ALU에 인가되 3이 변하는 것.
하지만 다음 클럭이 인가되기 전까지는 1의 값은 변하지 않습니다.
결과적으로 매 클럭이 인가될 때마다 결과 레지스터에는 중간 결과값이 쌓여 합산되는 것.

CPU의 클럭속도
CPU의 성능을 평가하는 가장 일반적인 요소가 클럭속도입니다.
이제 64비트로 처리량을 늘린다거나 하이퍼 스레딩으로 일종의 병렬화 기술 등을 통해 다른 방향으로 개선중.
클럭 주기는 곧 회로의 동작 성능에 직결되는 요소.
하지만 전기 신호의 속도가 유한하므로 출력값이 안정화되기까지는 다소의 시간이 걸립니다.
따라서 클럭이 인가되어 ALU의 입력이 변화하면 다소의 시간 후에 결과가 변함.
만약 일찍 다음 클럭이 인가되면 안정화되지 않은 엉뚱한 값일 수 있다.
그리고 CPU의 소형화가 거의 물리적 한계에 이르렀다.
3GHz CPU는 이 제약이 더 심해서 10cm 정도밖에 전달되지 않습니다.
CPU발열 문제도 해결해야 합니다.
그래서 이제는 CPU를 병렬로 사용해서 CPU가 분업할 수 있는 형태로 개선하는 방향.

*/