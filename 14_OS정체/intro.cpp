/*
선점형 OS는 비선점형 OS와 어떻게 다를까?
비선점형 OS는 프로그램 실행의 주체가 되는 스레드간의 문맥 전환을 각 프로그램의 자발전인 CPU반환에만
의존하는 반면 선점형 OS에서는 일정시간 동안 스레드가 자발적으로 수행권을 내놓지 않으면 인터럽트를 이용해
OS가 수행권을 가로채거 여기서 강제로 다른 스레드에게 수행권을 주게 됩니다.
요즘은 선점형 OS로 바뀌면서 훨씬 안정적인 성능 향상.

01 누구냐 넌? - OS
실제로 대부분의 경우는 프로그램이 돌아가기 위해서 OS(Operating System)가 필요.
OS가 없다면 Hello World프로그램도 만들기가 쉽지 않다.
마우스 클릭만 할 줄 알면 탐색기가 파일과 폴더들을 보기 쉽게 나열해주고 메뉴에 모든기능들이 가있다.
그래서 사람들이 OS가 좋아졌기 때문에 작업이 쉬워졌다고 생각할 수도 있지만
도스시절에도 파일이나 디렉토리 개념이 있었고 얼마든지 파일복사를 할 수도 있었습니다.
Norton COmmander나 m으로 파일 관리 프로그램도 있었습니다.
쉘(Shell) 프로그램도 윈도우즈에 부속적으로 딸려오는 프로그램을 두고 OS라고 생각하지만
바탕화면에 있는 아이콘이나 시작버튼을 눌러 프로그램을 실행하는 기능들을 제공하는 일종의 프로그램일 뿐입니다.
작업관리자를 띄어 프로세서에서 explorer.exe를 종료시키면 바탕화면에 있는 아이콘이나 작업줄이 사라집니다.
결국 윈도우즈에서 접하던 화면도 사실은 OS가 아니라 하나의 프로그램일 뿐입니다.
C:\>프롬프트도 실상은 Command.com이라는 쉘프로그램인 것입니다.
도스를 경험하는 것이 아니라 PC가 부팅되면서 자동으로 실행된 Command.com을 작업하고 있던 것.
윈도우즈 화면이나 커맨드창은 해당 OS위에서 돌아가는 하나의 프로그램일 뿐입니다.
이 프로그램은 다른 프로그램을 쉽게 실행할 수 있도록 사용자에게 인터페이스를 제공하는 역할을 하는 것뿐.
OS는 운영체제라고 하는 일종의 소프트웨어입니다.
OS라는 것은 법이나 이프라에 해당하는 존재입니다.
구성원들이 서로 간에 충돌이 일어나지 않으면서 서로 협조하고, 자신의 역할을 효율적으로 수행할 수 있도록
기반시설을 제공해주는 범규와 인프라 같은 존재.
OS위에서 돌아가는 Hello World프로그램을 만들고 실행하는 것은 간단합니다.
OS가없다면 모니터 화면에 점이라도 찍어보려면 비디오 카드를 직접 액세스하는 코드를 작성해야하고
비디오 모드를 원하는 모드로 전환하고 원하는 위치에 점을 원하는 색으로 찍을 수 있도록 프로그램을 만들어야 합니다.
비디오 카드가 바뀌면 다시 만들어야하고 글자를 찍기 위해서는 폰트 데이터도 있어야 합니다.
모니터에는 점 단위로 표현을 해야하기 때문에 글자를 표시하기 위해 점들이 어떤 위치에 찍히는지에 대한 정보도 필요.
이런 정보가 폰트이고 OS가없다면 직접 코드상에 그에 해당하는 데이터를 가지고 있어야 합니다.
OS가 없고 파일 개념도 없는 상태이므로 PC전원이 들어오면 CPU의 PC레지스터의 초기값에 해당하는 주소,
즉, CPU가 가장 먼저 인스트럭션을 읽어오기 시작하는 주소에 코드가 들어있어야 합니다.
램은 전원이 꺼지면 내용이 다 사라지므로 ROM에 직접 프로그램을 구워서 CPU의 시작 주소에 프로그램이 위치할 수
있도록 주소를 계산하여 롬을 CPU와 연결해야 합니다.
프로그램이 수정되면 매번 롬을 구워 물리적으로 다시 PCU와 연결하는 작업을 반복해야 할 것입니다.

초창기 일괄처리 시스템에서는 많은 사용자들이 컴퓨터를 공용으로 사용하는 형태였습니다.
프로그램을 작성해서 관리자에게 가져다 주면, 관리자가 그 프로그램을 돌리고 결과를 프린트해서 돌려주는 형태.
문제는 이런 작업이 산재해 있을 때, 실질적으로 CPU의 이용률이 매우 낮다.
한 명의 코드를 돌려 결과를 프린트하기까지 대부분의 시간을 소비해야 했고 CPU가 쉬어도 다음 사람은 기다려야 했습니다.
좀 더 효율적으로 하기 위해 프린트 스풀링(Spooling) 같은 개념을 도입하고, 여러 사용자의 작업을 동시에 메모리에
적재해 한 작업이 끝나면 결과물은 스풀링하고 자동으로 다음 작업으로 넘어가도록 하는 것이 초창기 OS의 목적.
처음 한번만 작업을 여러 개 메모리에 적재해두고 순차적으로 알아서 하게하는(지금의 스크립트작업) 것이 OS의 역할.
이러한 작업을 해주는 것을 일괄처리 시스템이라고 불렀습니다.
일괄 처리 시스템도 결국은 한 번에 적재된 작업에 한해서만 연속으로 처리할 뿐, CPU가 유휴상태일 때도 많다.
한 프로그램이 중간에 I/O장치를 많이사용하면 상대적으로 CPU보다 느린 기계적인 I/O장치로 인해 CPU는 유휴상태.
이를 개선하기 위해 OS는 한 프로그램이 끝나고 나서 다음 작업으로 넘기는 것이 아니라 프로그램이 중간에 
I/O작업을 기다려야 하는 상황이 발생하면, 그 작업이 끝날 때까지 다른 프로그램을 실행하는 것.
그리고 새롭게 실행이 되는 프로그램 역시 대기 상태가 되면 또 다른 프로그램을 다시실행하거나 멈췄던 프로그램 실행.
이를 다중 프로그래밍(Multi-Programming) 혹은 멀티태스킹(Multi Tasking)이라고 하는데 스케쥴링의 필요성이 대두.
다른 프로그램을 실행해야 하는 상황이 발생했을 때 어떤 프로그램을 선택해야 하는지가 문제.

02 선점과 비선점 방식
도스는 전형적인 일괄 처리 시스템의 일종이었다.
램 상주(Terminate and Stay Resident - TSR)라고 하는 형태로 마치 동시에 다른 프로그램이 실행되도록 하는 것이
있지만, 진정한 의미의 멀티태스킹이 아닙니다.
이 방식은 램 상에 프로그램 코드를 남겨둔 채로 도스에게 프로그램이 종료된 것처럼 알려주고 추후에 다른 프로그램을
실행하다가 어떤 이벤트가 발생하면(인터럽트 등) 다시 램 상주 프로그램이 있는 메모리로 제어권을 넘기는 방식.
이는 현재 실행 중인 프로그램과 교대로 실행하는 방식.
도스는 본질적으로 한 번에 하나의 프로그램만을 수행하는 일괄처리 시스템.
윈도우즈 프로그램은 도스와는 달리 이벤트 드리븐(Event Driven)방식으로 이벤트가 발생하면 그 이벤트에 대해서만
처리하고 다시 다음 이벤트가 발생할 때까지 Sleep모드로 들어가서 다른 프로그램에게 CPU를 양보하는 방식.
도스프로그램은 자신 혼자만이 돌아간다 생각해 main함수 내에서 루프를 돌면서 계속해서 화면을 갱신하거나
그런 식으로 항상 CPU를 점유하고 있습니다.
윈도우즈에서 도스 창을 열 순 있지만, standard모드에서는 다른 윈도우즈 프로그램과 동시에 돌아갈 수 없습니다.
이런 방식의 멀티 프로그램, 멀티태스킹을 '선점형 멀티태스킹(Preemptive Multitasking)'이라고 합니다.
말그대로 한 프로그램이 제어권(CPU)을 선점하고 있으면, 스스로 그 제어권을 양보하지 않는 이상 다른
프로그램이 가져올 방법(실행할 방법)이 없다는 것.
도스에서는 C에서 제공하는 표준 라이브러리만 사용해서 프로그램을 작성하는데,
윈도우즈 같은 멀티태스킹 OS에서는 WIN32 API라고 부르는 C의 표준라이브러리말고 다른 OS표준라이브러리를 같이 사용.
유닉스 계열에서는 시스템 콜(System Call)이라고 하는데 결국 OS가 제공하는 편의성을 위한 함수이기는 하지만,
응용 프로그램은 이 API(나 시스템 콜)을 통해서 작성되어야만 해당 OS위에서 안전하게 돌아갈 수 있도록 하는
일종의 규제 같은 것이기도 합니다.
API에는 여러 함수가 있는데 편리함을 제공할 뿐 아니라 다른 프로그램과 동시에 돌아갈 수 있도록 설계된 함수.
윈도우즈를 생성하기 위해 CreateWindow라는 함수가 있고, I/O작업을 하기위해 Read나 Write같은 함수도 제공.
윈도우즈 프로그램은 이벤트가 발생하면 이벤트를 처리하는 방식이어서 GetMessage같은 메시지를 얻는 API도 있다.
제어권의 양보는 이러한 API 함수를 부를 때 발생합니다.
GetMessage는 메시지가 발생하지 않으면 계속 대기상태로 있는데 GetMessage 함수 안에서 다른 대기 중인
프로그램을 실행하도록 스케줄링이 일어나는 것.
I/O함수 역시 Read함수가 불리면 디바이스 드라이버에게 알려준후 실제 데이터가 들어올 때까지 기다리는데,
그 안에서 다시 다른 프로그램을 실행하도록 스케줄링하고, 디바이스 드라이버가 해당 작업을 마무리하고 나면
이벤트 방식으로 본 프로그램에게 알려주는 방식.
결국 프로그램에서 API를 사용해 대기를 요하는 API함수(GetMessage, Read)를 부르는 자체가 제어권을 양보하는 것.
윈도우즈 프로그램에서는 순차적인 코드 진행이 아닌 외부로부터의 이벤트가 발생하면 OS가 이를 적절하게
현재 포커스된 프로그램에게 메시지 형태로 전달하고, 각 프로그램은 무한루프를 돌면서 그 안에서 GetMesage라는
API함수를 불러 메시지를 읽어오고 해당 메시지에 맞는 처리를 하는 방식으로 진행되어 
대부분의 시간을 GetMessage 함수 안에서 보내는 것.
이벤트 드리븐 방식으로 돌아가는 윈도우즈 프로그램 예.
int WinMain() {
	//Main message loop:
	while (TRUE) {
		GetMessage(msg);
		switch(msg) {
		case WM_PAINT: //화면을 갱신.
		...
		}
	}
}

선점형 방식의 멀티태스킹은 어떨까?
내부적으로 긴 수학적 연산을 수행해야 하는 프로그램을 만든다고 생각해보자.
프로그램에서 Decode라는 함수가 있어 함수 내부에 주어진 데이터를 디코딩한다고 가정해보자.
이 함수가 복잡하고 길어서 1분이 소비된다고하면 모든 프로그램이 1분동안 기다려야 한다.
선점형 멀티태스킹방식에서는 능동적으로 제어권을 가진 프로그램이 GetMessage 같은 API함수를 불러서
제어권을 넘겨주지 않는 이상 CPU는 계속 그 프로그램만을 수행할 것이다.
일부러 while(TRUE)같은 코드로 무한 루프를 돌면서 API함수들을 불러주지 않으면 다른 프로그램이
CPU를 차지할 기회가 없어 결과적으로 시스템 전체가 먹통.
이를 위한 것이 비선점형(non preemptive)방식.
비선점형은 프로그램 하나가 CPU를 독점할 수 없는 방식.
아무리 while(TRUE)로 루프를 도는 프로그램을 만들어도 CPU를 혼자 독점할 수 없다.
다른 말로 시분한 시스템(Time Sharing System)이라고 하는데 CPU의 제어권 이전을 각 프로그램의 자발성에
맞기는 것이 아니라 강제적으로 OS가 조금씩 프로그램마다 시간을 할당해 
한 프로그램이 CPU를 독점하는 것을 근본적으로 방지.
윈도우즈 XP같은 OS가 시분할 시스템, 비선점형 멀티태스킹 시스템입니다.
윈도우즈에서 최초로 도입된 것은 95부터지만 실제론 대형 컴퓨터에 쓰였던 UNIX같은 시스템에서 사용했었다.
이를 개인 PC로 옮겨와 구현한 것이 95.

정확하게 말하기는 어렵지만 역할에 대해 정의해보면
1)OS는 사용자에게 편리성을 제공하기 위한 일종의 라이브러리입니다.
라이브러리는 자주 사용되는 기능을 묶어 함수 형태로 미리 작성해 둔 코드.
라이브러리는 다른 프로그램에서 수동적으로 호출되어 사용되는 함수의 집합.
사실 OS는 그 자체로서는 어떠한 능동적인 역할도 하지 않습니다.
OS는 도로나 신호등과 같은 규칙을 만들고 라이브러리 형태로 제공합니다.
OS에서 실행되는 실행 코드는 실제 프로그램 코드 이외에도 해당 OS위에서 돌아가기 위한 여러 가지 다른
정보를 포함하고 있어야 합니다.
운전자도 차량 조작만 할 줄 아는 것이 아니라 교통 체제를 이해하고 있어야 한다.
OS위에서 돌아가는 프로그램은 그 OS상에서 필요한 정보를 실행 파일 안에 헤더와 같은 형태로 담고 있어야 한다.
이 프로그램은 운영체제가 제공하는 함수 API를 사용함으로써 운영체제 안에서 적절하게 조화를 이루며 실행.
도스프로그램을 만들 때는 글자를 찍으려면 printf를 사용하지만 윈도우즈에선 TextOut이나 DrawText같은 API.
윈도우즈를 그리려면 CreateWindow API를 사용해야지 임의로 프로그램이 비디오카드를 직접액세스해서 그리면 안됨.
보통 CPU차원에서 실행 레벨이라는 으용프로그램이 규칙을 어기고 독단적으로 행동하는 것을 막기 위한 존재.
이런 장치가 없더라도 해당 OS에서 조화를 이루며 돌아가기 위해서는 반드시 OS가 제공하는 API를 사용해야 한다.
OS에서 여러프로그램이 동시에 돌아가는 것이 능동적으로 실행시켜 멀티태스킹을 구현한다고 생각하면 안되고
각 응용 프로그램이 OS의 API함수를 부를 때 비로소 스케줄링이 일어나 다른 프로그램이 실행되는 것.
Read같이 외부 장치에 명령을 주고 결과를 대기해야 하는 API함수 등이 내부적으로 장치에 명령을 전달한 후
바로 리턴하는 것이 아니라 스케줄링하는 코드를 호출합니다.
즉, 응용프로그램이 이러한 API함수를 부를 때마다 비로서 다른 프로그램이 실행될 기회를 얻는 것.
시분할하는 선점형 OS에서는 인터럽트를 통해 API함수 호출없이 스케줄링합니다.
결국 OS는 여러 응용 프로그램이 동시에 잘 실행되면서 편리하게 작성될 수 있도록 API를 제공하는 라이브러리 같다.
그런 API를 불러줄 응용 프로그램이 없다면 OS는 그 자체로는 아무 일도 할 수 없다.
2)OS의 목적은 효율적인 시스템 운영을 위한 것.
초창기에는 CPU가 수시로 쉬었기 때문에 OS가 등장했고 OS가 동시에 여러 사람의 작업을 받아 자동적으로
조금씩 실행하면서 최대한 CPU가 쉬지 않도록 해주는 것이 관심사.
이런 효율성의 문제는 사실 요즘에는 하드웨어 비용이 저렴해져서 무색해졌지만 대신 OS는 새로운 패러다임을
통해 여전히 시스템의 효율적인 운영에 큰 몫을 차지합니다.
예전에는 응용 프로그램이 직접 하드웨어에 대한 부분까지 신경써야 했다면(게임자체 사운드카드 그래픽카드 등등)
지금은 OS가 이런 부분을 떠맡아 디바이스 드라이버라는 형태를 통해 하드웨어와 응용 프로그램을 분리시키게 됨.
예전에는 개발자가 모든 사운드 카드에 대한 제어 코드를 작성해야 했지만 지금은 디바이스 드라이버라는 형태.
개발자는 장착된 사운드 카드에 대해 신경쓰지 않고 OS가 제공하는 API함수를 통해 소리를 낼 수 있다.
OS만 일정하다면 아무리 하드웨어가 바뀌어도 개발자는 쉽고 빠르게 원하는 기능에만 초점을 맞추어 개발할 수 있고
하드웨어에 대한 지원은 해당 하드웨어를 개발하는 쪽에서 전담하도록 하여 전체적인 시스템 개발의 효율성이 증가.
결국 컴퓨터는 사용하는 목적은 다양한 기능을 제공하는 응용프로그램을 사용하기 위한것.

*/