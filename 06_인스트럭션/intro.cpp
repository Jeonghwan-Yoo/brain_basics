/*
인스트럭션(Instruction)이란 무엇일까요?
CPU를 동작시키기 위한 명령어.
훌륭한 CPU라도 기껏 수십 개 정도의 인스트럭션밖에 지원하지 않습니다.
인스트럭션의 집합을 인스트럭션 셋(Instruction set)
CPU의 전형적인 특성은 바로 이 인스트럭션 셋에 의해 결정됩니다.

RISC와 CISC의 차이는 무엇일까요?
인스트럭션 셋이 어떤 특징을 지니느냐에 따라 CPU를 구분하는 방식.
RISC는 모든 인스트럭션이 동일한 길이를 지니고 있으며 인스트럭션 수 역시 무척 적습니다.
최대한 단순한 인스트럭션 셋을 지원하는 CPU를 RISC라고 합니다.
반면 CISC는 인간의 언어처럼 여러 길이의 복잡한 익스트럭션 셋으로 구성된 CPU.
RISC는 인스트럭션 셋을 단순하게 구성함으로써 개개의 인스트럭션 수행 시간이 CISC보다 훨씬 빠를 수 있다.
결정적으로 파이프라이닝이라는 병렬 진행 방식을 통해 CISC보다 훨씬 빠른 수행 속도를 보입니다.
따라서 최근의 CPU는 RISC나 혼합방식.

01 프로그램 저장방식 컴퓨터
어떤 연산을 행하기 위한 입력값이나 연산 종류 등을 미리 기록해서 메모리에 저장(Store)하고
이를 순차적으로 실행하는 방식. Stored-Program Computer 혹은 축적 프로그램용 컴퓨터.
또한 CPU가 어떤 동작을 하기 위해서 필요한 내용을 기술한 것이 프로그램.
특히 프로그램이 그 종류에 상관없이 CPU에게 할 일을 명세한 작업지시서 같은 개념이라면
좀 더 구체적으로 CPU가 동작하는 행위 자체를 지시하는 값을 인스트럭션이라고 합니다.
즉 프로그램은 다소 추상적인 개념이지만 인스트럭션은 정형화된 형태로 CPU가 인지할 수 있게 구체화.
여러 개의 인스트럭션을 미리 작성하여 메모리(주기억장치)에 기록해 두고 CPU가 이 인스트럭션을 
차례대로 읽어와서(FETCH) 실행하는 것이 프로그램 저장방식 컴퓨터의 가장 큰 개념.
인스트럭션이란 ALU가 행할 연산의 종류, '동작입력값'.
동작입력 외에 인스트럭션이 갖춰야할 부분이 연산할 입력값, 오퍼랜드를 지정하는 것.
32비트 CPU를 설계한다면 당연히 ALU도 32비트, 입력출력값도 32비트이므로 해당 오퍼랜드도 32비트의 값.
그런데 연산은 두 개의 오퍼랜드 사이에서 정의되는 것이므로 총 64비트가 필요합니다.
동작입력값까지 추가되면 그 이상이 필요하게 됩니다.
결과값은 다시 다음 연산을 하기 위한 소스가 될 수 있 도록 레지스터에 기록.
따라서 프로그램 저장 방식의 CPU에서는 ALU의 연산을 항상 레지스터에 저장합니다.
MIPS에서는 인스트럭션은 오퍼랜드의 타입을 고정된 상수값만으로 한정하지 않습니다.
이전 연산의 결과값이 레지스터에 저장되므로 오퍼랜드로 레지스터를 지정할 수도 있게 한 것.
오퍼랜드를 직접 상수값으로 결정하여 인스트럭션에 기록하는 방식을 I-타입 인스트럭션.
레지스터를 지정하는 방식을 R-타입 인스트럭션.
R-타입은 오퍼랜드로 레지스터가 사용된다는 의미에서 Register.
I-타입은 곧바로 인스트럭션에서 오퍼랜드 값을 가져온다 하여 Immediate.

정리해보면
인스트럭션은 CPU가 행할 작업을 지시하는 일종의 정형화된 언어이다.
사용자는 원하는 동작에 대해 인스트럭션을 차례대로 기술하여 메모리에 저장한다.
C프로그램 등이 컴파일 과정을 거쳐 인스트럭션 형태로 바뀌게 된다.
CPU는 일련의 메커니즘에 의해 인스트럭션을 메모리에서 순서대로 읽어와서 실행한다.
메모리에서 인스트럭션을 읽어오는 과정을 '인스트럭션 패치' 혹은 '패치'라고 한다.
인스트럭션은 연산의 종류를 나타내는 동작입력값과 연산의 대상이 되는 값인 오퍼랜드를 지정해야 한다.
동작입력을 나타내는 부분을 오퍼레이션 코드(operation code) 혹은 OP코드라고 한다.
연산의 결과는 레지스터에 저장되며 이 연산의 입력값인 두 오퍼랜드는 인스트럭션에 직접 상수 형태로
기록이 될 수 있으며 이러한 형태는 I-타입 인스트럭션이라고 한다.
반면에 오퍼랜드값이 임의의 레지스터에 저장되고 인스트럭션에는 이 레지스터를 지정하는 값이
들어가 있을 수도 있다. 이러한 형태를 R-타입 인스트럭션.

RAM과 ROM
RAM은 Random Access Memory의 줄임말, ROM은 Read Only Memory의 줄임말

02 인스트럭션의 구성요소
인스트럭션은 인간이 CPU에게 일을 시키기 위해 사용하는 아주 간단한 CPU 언어입니다.
인스트럭션은 순수하게 컴퓨터 디자이너의 구미에 맞춰 디자인되었습니다.
원칙으로는 CPU가 할 줄 아는 것을 정의하여 그 동작의 이름을 정의하는 것입니다.
ADD, SUB 등의 단어들이 인간이 알아보기 편하도록 알파벳으로 1:1매칭하여 나타내어진
것을 어셈블리(Assembly) 또는 니모닉 코드(Pneumonic Code)라고 합니다.
인스트럭션에서 이러한 연산 종류를 나타내는 부분을 OP코드.
두 번째로 고려해야 할 점은 연산의 대상이 되는 오퍼랜드를 지정하는 일입니다.
인스트럭션에는 OP코드와 두 개의 오퍼랜드, 기타 다른 정보들이 들어있습니다.
한가지 더 고려한다면 결과값을 어느 레지스터에 저장할 것인가.
8031/51같은 CPU에서는 타겟 레지스터를 따로 두지않고 Accumulator에 고정된 레지스터에 저장했습니다.
최근에는 임의의 레지스터에 결과값을 저장할 수 있도록 하는 구조가 일반적.
그래서 CPU인스트럭션에는 타겟 레지스터를 지정하는 부분이 따로 마련이 되어 있습니다.
소스 레지스터 및 타겟 레지스터는 특정한 용도로 특화된 경우가 많아 개별적인 이름으로 나타냄.
AC(Accumulator), AX,BX,CX,DX(범용 레지스터)
ADD AX, BX #AC = AX + BX
ADD AC, CX #AC = AC + CX
AC가 있는 구조에서는 연산의 결과는 항상 AC에 저장되므로 명시적으로 타겟 레지스터를 지정하지 않고
두 개의 오퍼랜드만 지정하면 됩니다.
한편 두 오퍼랜드 모두가 레지스터가 아니라 하나의 오퍼랜드에 상수를 직접 기입할 수 있는 인스트럭션.
ADDI AX, 4 #AC = AX + 4
AC없이 BX레지스터로 결과값을 저장하고 싶다면
ADDI BX, AX, 4 #BX = AX + 4
꼭 타겟 레지스터가 앞에 와야 하는 것은 아닙니다. 관례적인 부분.

프로그램 사이즈는 곧 주메모리의 크기에 제약을 받게 되므로 인스트럭션의 사이즈는 가능한 작은 것이 좋다.
만약 CPU 내부에 32개의 8비트 레지스터가 있고 AC는 없다고 하자.
레지스터가 8비트이므로 ALU도 8비트일 것이며 CPU는 8비트 CPU.
5비트만 있으면 레지스터를 지정할 수 있고, 3비트만 있으면 OP코드 사용할 수 있다.
R-타입에서는 3+5+5+5해서 18비트, I-타입에서는 3+5+5+8(상수)해서 21비트 필요.
실제 CPU에서는 데이터 이동을 위한 인스트럭션이 존재합니다.
어떤 결과의 결과값을 제곱하고자 한다면, ALU연산 후 AC레지스터의 결과값을 다른 레지스터로 옮기고
이를 다시 AC레지스터와 곱하면 됩니다.
MOV AX, AC #AX = AC
MUL AX, AC #AC = AX * AC = AC * AC
오퍼랜드가 하나뿐이므로 R-타입에서는 13비트만 있으면 됩니다.
또한 자주 일어나는 동작이 메모리와 레지스터 간의 데이터 이동입니다.
메모리에서 레지스터로 전송하는 경우를 LOAD, 레지스터에서 메모리로 전송하는 경우를 STORE.
총 16비트의 어드레스 라인과 8비트의 데이터 라인을 가진 메모리(2^16=64KB x 1B = 64KB)에서
3+5+16=24비트이므로 총 24비트가 필요합니다.
LOAD AX,[123] #AX = Memory[123]
STORE AX,[321] #Memory[321] = AX
LOAD, STORE의 인스트럭션 길이에 따라 연결할 수 있는 최대 메모리 사이즈가 결정될 겁니다.
레지스터의 개수에 따라 전체 인스트럭션 사이즈도 변할 수 밖에 없습니다.
따라서 인스트럭션의 종류와 하드웨어의 스펙에 따라 필요한 최소 사이즈는 서로 다를 수 밖에 없습니다.

마지막으로 인스트럭션의 수행시간이라는 것을 이야기하기 위해 클럭 사이클 타임과 Clock Per Instruction(CPI)
Clock Cycle Time은 한 클럭의 주기를 일컫습니다.
CPI라는 것은 인스트럭션당 클럭 횟수를 일컫는 단위.
ADD나 OR처럼 한번의 ALU연산으로 결과를 얻는 경우는 1CPI.
ALU연산과 레지스터간의 데이터 이동은 한 회로 안에 구성되어 있으므로 매우 빠른 속도로 이루어지지만
LOAD, STORE처럼 메모리를 액세스하는 인스트럭션은 CPU보다 느린속도의 메모리를 거치므로 더 오래걸린다.
그러면 모든 인스트럭션들은 클럭에 동기화되어야 하므로 LOAD와 STORE 때문에 
1CPI로 만들기 위해서는 주기를 길게 잡아야 한다.
그러면 다른 연산을 하면 기다려야하므로 전체의 성능을 무척 저해하는 요소가 된다.
초창기에는 CPU가 많은 기능을 가지도록 여러 인스트럭션을 만들고 각 인스트럭션은 최소의 사이즈를
가지도록 꼭 필요한 필드만 만들어 넣었습니다.
그러다보니 각 인스트럭션은 서로 다른 길이를 지니게 되었습니다.
그리고 모든 인스트럭션을 한 클럭에 수행하도록 설계하는 대신 클럭주기를 짧게하고 각각의 인스트럭션마다
필요한 횟수, CPI를 달리 하도록 설계했습니다.
이런 형태는 CISC(Complex Instruction Set Computer)방식이며 80386까지 이 구조를 고집했다.
CISC는 각 인스트럭션을 가변적인 길이를 갖도록 설계하므로 프로그램을 최소의 메모리를 점유하면서 실행.
CPU가 개선됨에 따라 새로운 인스트럭션을 추가해도 가변길이 구조기때문에 기본 구조가 크게 바뀌지 않아
하위 CPU와 호환성을 유지할 수 있습니다.
하지만 CISC방식에선 인스트럭션 종류가 많고 길이도 달라 하드웨어적인 설계가 복잡해졌습니다.
80386에서 성능개선에 한계가 있어 1980년대 초반에는 구조적인 차원에서 개선하고자하는 노력.
다른 임베디드 계열 CPU나 워크스테이션에서는 RISC방식의 CPU가 주류였습니다.
가능한 인스트럭션을 단순하게, 일정한 형태로 만들어 하드웨어를 간단하게 구성하는데 목적.
모든 인스트럭션 사이즈를 동일하게 설계해 이후에 파이프라이닝을 도입할 수 있었다.
파이프라이닝 기술은 인스트럭션의 수행을 몇 클럭으로 일정한 단계별로 나누어 각 단계마다 별도의
하드웨어를 지원하여 동시에 여러 개의 인스트럭션이 수행될 수 있도록 하는 방법.
그래서 80486이후부터는 RISC기술을 적용하기 시작했습니다.
하지만 하위 CPU와의 호환 문제로 100%는 아니었습니다.
RISC방식은 속도가 느린 메모리 액세스에 대해서는 최소의 인스트럭션만 제공하고,
대다수의 인스트럭션을 속도가 빠른 레지스터 간의 연산만으로 제한합니다.
그래서 일반적으로 CISC보다 많은 수의 범용 레지스터를 갖습니다.
레지스터 개수:(CISC)메모리와 직접 연산을 하는 인스트럭션이 많고 일반적으로 연산을 저장하는 AC가 있어
다수의 레지스터가 필요없다.
(RISC)메모리 액세스는 일반적으로 LOAD/STORE정도의 인스트럭션으로 제한되며 나머지는 모두 레지스터기반의 연산으로
상대적으로 레지스터 개수가 많다.
인스트럭션 길이:(CISC)각 인스트럭션마다 가변적이다.
(RISC)모든 인스트럭션이 동일하며 일반적으로 CPU의 처리단위인 1Word와 동일하게 맞추어져 있다.
인스트럭션수행시간:(CISC)인스트럭션마다 최소의 수행시간에 맞추어 가변적으로 설계.
따라서 필요한 내용만 해석하면 되므로 디코딩 시간이 짧다.
(RISC)모든 인스트럭션이 동일한 단계를 거쳐 수행되며 대부분의 인스트럭션은 각 단계별로 비슷한 실행시간.
단 메모리 액세스 등 일부 실행 시간이 긴 인스트럭션은 STALL이라고하는 딜레이가 생길 수 있다.
인스트럭션개수:(CISC)다양한 인스트럭션이 많이 제공된다.
(RISC)단순한 인스트럭션만 이루어져 있으며 그 개수 또한 적다.
컴파일러 설계:(CISC)인스트럭션의 복잡성으로 효율적인 코드생산이 어렵고 컴파일러 자체의 설계도 복잡.
(RISC)인스트럭션이 단순하므로 컴파일러 설계도 간단해지고 효율적인 코드 생산이 가능.
하드웨어 설계:(CISC)복잡하게 되며 안정성 문제도 발생하며 가격 또한 비싸진다.
(RISC)단순하므로 신뢰도가 높고 개발 주기도 짧아져 빠른 시장 대응을 할 수 있다.

메모리 액세스 인스트럭션
LOAD/STORE을 해서 한번에 못옮긴 이유는 메모리 유닛 자체가 Read/Write를 동시에 할 수 없다.
메모리 유닛에서 Read를 하기 위해서는 어드레스 라인에 주소값을 주고 Read라인을 Enable하면, 
Read데이터 라인으로 데이터가 나옵니다.
Write의 경우 어드레스 라인으로 주소를 주고 Write데이터 라인으로 기록할 데이터를 주고 Write라인을
Enable한 상태로 잠시 유지하면 값이 기록됩니다.
그런데 데이터를 메모리에서 읽어와 같은 메모리에 저장하기 위해서는 Read 데이터 라인을 다시 Write 데이터
라인으로 연결하도록 구성해야 합니다.
결국 이 값을 중간에 저장할 곳이 있어야 하므로, 레지스터에 값을 한번 읽어온 다음 클럭에 다시 기록.
레지스터 역시 동기 메모리 소자이므로 클럭에 맞춰 Read/Write가 이루어진다.
결국 한 클럭 내에서는 동시에 일어날 수 없습니다.
이러한 제약에 의해서 메모리 간의 데이터 이동 인스트럭션은 RISC방식 CPU에는 없고
대신 LOAD나 STORE처럼 레지스터-메모리 간 데이터 이동에 관한 인스트럭션만 존재합니다.

*/