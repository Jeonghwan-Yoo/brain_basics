/*
인스트럭션과 어셈블리어의 차이점?
CPU는 0과 1로만 이루어진 인스트럭션을 통해 동작합니다.
CPU의 언어가 바로 인스트럭션.
인간이 알아보기 편한 형태로 바꾸어준 것을 어셈블리어라 합니다. 
결국 어셈블리어와 인스트럭션은 1:1로 매칭.

고급언어와 어셈블리어, 그리고 인스트럭션의 관계?
어셈블리어와 인스트럭션은 1:1로 맵핑된 서로 다른 언어로 같은 맥락이라고 할 수 있습니다.
하지만 고급언어는 1:1로 번역한다는 것이 불가능합니다.
그래서 해석해주는 컴파일러가 필요하고, 복잡합니다.

01 CPU의 청동기 시대 - 어셈블러
'조합논리회로'라는 것은 입력이 주어지면 출력이 결정되는 회로. C의 함수 같은 것.
변수는 상태(state)값을 저장하는 공간으로 이 상태값이 입력과 함께 프로그램의 적절한 출력을 만들어내도록 한다.
(3 + 4) * 5에서 우선 3+4라는 연산을 하여 리제스터나 메모리에 저장해 두고 다시 그 결과값이랑 5를 곱하는 연산.
이 때 필요한 중간 상태를 저장하는 저장공간, 즉 메모리나 레지스터 같은 것들이 바로 (상태)변수입니다.
입력은 CPU입장에서 외부로부터의 모든 자극. 키보드, 마우스, 네트워크로부터의 데이터 등.
결과적으로 CPU가 원하는 형태의 전기적 신호값으로 바뀌어 입력으로 작용하고,
CPU는 이런 입력과 내부 상태 변수의 값과 함께 적절한 출력을 만들어 내는 것.
출력은 CPU의 출력값으로 영상이나 음악 글자 등등.
하지만 CPU는 단지 전기적 신호를 출력 핀으로 내보낸 것.
이를 디바이스들이 받아들이며 비디오카드는 모니터, 사운드카드는 스피커 등등으로 표현해줌.
순차논리회로는 입력과 상태값을 가지고 출력을 만들어내는 CPU같은 것입니다.
순차논리회로는 출력이 입력과 내부의 메모리에 저장된 상태 값에 의해 결정되는 회로.
특별히 입력을 키보드나 마우스 물리적 장치와 메모리에 저장된 값을 받는 순차논리회로를 CPU라고 하는 것.
이 때 메모리에서 가는 입력값을 해야 할 일을 지정한다 해서 인스트럭션이라고 부르는 것.
CPU는 상태값을 레지스터에 저장하고 메모리로부터 입력값을 받습니다. 입력값이 인스트럭션이고 레지스터의 값에
따라 CPU의 행동이 결정되는 것.
키보드나 마우스같은 I/O장치로부터 외부 입력을 받을 수 있고 역시 입력값.
인스트럭션도 결국 순차 논리회로의 입력 중 하나.
다만 IO장치 같이 외부로부터 데이터가 발생할 때마다 들어가는 비동기적 입력이 아니라,
메모리처럼 저장장치에 미리 입력값을 저장해 놓고 순차적으로 적용시킬 수 있어 프로그래밍(Programing)이라고 한다.
초창기 컴퓨터에서는 인스트럭션에 해당하는 입력을 메모리 대신 사람이 외부에서 파이프 조작해서 구성했다.
CPU는 프로그램을 만들어 이것저것 만들 수 있어 유연성이 매우 좋습니다.
이론적으로 어떤 프로그램이든 논리회로를 통해 칩형태로 구현할 수 있겠지만 복잡도가 엄청 큽니다.
인스트럭션을 1:1로 맵핑하여 어셈블리라고 하는 인간이 좀 더 알아보기 쉬운 형태의 프로그램을 어셈블러(Assembler).
어셈블러는 문장을 정확하게 인스트럭션으로 번역해 냅니다.
단순히 단어들을 분리하고, op코드와 레지스터 인덱스 값을 조합해 내보내면 되는 것.
이를 통해 인스트럭션을 바로 사용하는 것보다 훨씬 더 편리하게 프로그램을 만들 수 있고,
점프 주소를 직접 계산할 필요가 없습니다.
어셈블러로 복잡하고 긴 프로그램을 비교적 인간이 알아볼 수 있는 형태로 만들 수 있게 됨.

02 CPU의 철기 시대 - 고급 언어의 등장
어셈블리는 결국 CPU를 이해하고, 내부 레지스터 등을 사람도 똑같이 이해해야 합니다.
결국 CPU종속적입니다. 그러면 다른 플랫폼으로 이식하는 것이 불가능.
CPU가 바뀌면 인스트럭션 셋이 모두 바뀌고, 프로그램을 다시 만들어야 하기 때문.
실제로도 지금까지도 어셈블리어는 요긴하기 쓰이긴 합니다. 세밀하게 조작할 수 있다는 의미.
가장 정밀하고 최소의 인스트럭션만으로 원하는 기능을 구현하므로 아주 적은 사이즈로 효율적인 프로그램 가능.
매우 치밀한 속도를 요하는 핵심 알고리즘이나 세밀한 조작을 해야 하는 경우는 여전히 어셈블리어 사용.
실실적으로는 대다수의 프로그램은 CPU와는 거의 무관하게 이루어져 있습니다.
결국 사람들은 이런 부분을 간파해 좀 더 효율적이고 코드의 재사용이 가능한 표준 언어를 찾기 시작.
고급언어는 CPU에 의존하지 않고, 인간의 입장에서 기술하면 적절하게 CPU가 알아볼 수 있는 인스트럭션으로 변경.
사실 많은 고급 언어 컴파일러는 인스트럭션이 아니라 어셈블리어로 번역을 하고 나서 다시 인스트럭션으로 변경.
고급언어는 1:1 변환이 아닌 문장을 파악해 유연하게 번역을 해야합니다.
if(a >= b) c = 1 이라고 기술하면
LOAD $r1,MEM[A] #$r1 = MEM[A]
LOAD $r2,MEM[B] #$r2 = MEM[B]
JLT SKIP,$r2,$r1 #Jump to SKIP if $r2 is less than $r1
STORE MEM[C],1 #MEM[C] = 1
SKIP:
컴파일러는 문장을 파악해야하고 변환하고자 어셈블리어도 알고 있어야 합니다.
즉 CPU가 바뀌게 되면 C컴파일러도 바뀌어야 한다는 의미.
그래서 MIPS용 컴파일러로 PC에서 돌아가는 프로그램을 만들 순 없습니다.
하드웨어와 관계없이 모든 프로그램은 사실 PC에서 만들어지고 있습니다.
대부분 C언어로 작성하고 컴파일하는 컴파일러를 해당 CPU에 맞는 것을 사용하는 것.
이런 형태의 컴파일러를 크로스 컴파일러(Cross Compiler).
플랫폼을 가로질러 다른 플랫폼의 인스트럭션을 생성해내는 컴파일러. 크로스 컴파일러.
PC에서 작성하는 이유는 타켓 CPU의 컴파일러들이 대부분 PC용 프로그램이기 때문.
즉, 다른 CPU의 인스트럭션을 생성해내는 컴파일러들도 사실은 PC에서 돌아가도록 PC용 컴파일러로 컴파일된 프로그램.
또한 PC가 편하기 때문. 편리한 툴.

메모리 없는 CPU는 없고, 외부장치와의 인터페이스가 하나도 없이 모든 CPU에서 공통적으로 가능한 부분이므로
특별한 작업 없이 컴파일러를 바꿔주는 것만으로 이식이 가능하긴 합니다.
하지만 결과를 알아보기 위한 부분에 인간이 알아볼 수 없으면 무의미.
보통 CPU제조회사에서 컴파일러가 함께제공되는데, 컴파일러는 CPU마다 하나.
컴파일러는 고급언어를 타겟 CPU의 인스트럭션으로 번역해주는 툴이라 CPU에 의존적이기 때문.
printf를 사용하기 위해선 stdio.h라는 헤더파일을 include해야 합니다.
printf는 C의 표준 키워드가 아니어서 C컴파일러는 알아 볼수 없습니다. main도 키워드가 아닙니다.
결국 stdio.h에 정의된 printf라는 함수 선언을 보고 C컴파일러는 컴파일해 object파일을 만듭니다.
그리고 링크라는 과정을 통해 미리 지정된 라이브러리 중에서 printf라는 함수를 찾습니다.
그리고 이 함수가 발견되면 만든 object파일과 합치는 것.
LIBC.LIB같은 몇 가지 라이브러리는 컴파일 옵션에 따라 만든 object파일과 링크시킨다는 것을 의미.
결국 printf함수는 라이브러리 중 하나에 미리 정의되어 있고 불러다 쓰는 것.
C코드를 직접 수정해 액정에 점을 찍는 함수부터 만들기 시작해 폰트를 로드하고 글자까지 출력하도록 만들 수 있지만,
라이브러리만 존재한다면 링크되는 라이브러리를 메인 액정에 출력하는 printf가 정의된 라이브러리로 바꾸면 됨.
CPU입장에선 출력한다는 의미보다, 특정 포트로 데이터를 내보내는 것.
즉, CPU는 외부 핀에 연결된 포트에 상관없이 데이터 값을 출력할 뿐이고 해당포트에 연결된 장치가 처리하는 것.
그래서 결국 전용 라이브러리는 존재하기 힘듭니다.
윈도우즈같이 대중화되고 표준화 된 것은 예외.

결론적으로 PC용으로 만든 게임을 핸드폰으로 옮기려면 재컴파일하는 것으로 끝나지 않고,
PC와 핸드폰의 여러가지 하드웨어 차이점을 고려해 소스 수정을 해야 합니다.
하지만 알고리즘 파트는 고정이고 하드웨어 의존적인 부분만 수정함으로써 적은 시간 안에 다른 플랫폼에서 동작하게.
그리고 이런 것을 가능하게 해주는 것이 표준화된 고급언어.
C++는 기본적으로 C언어의 문법을 바탕으로, 객체지향 설계기법을 적용할 수 있게 발전된 형태의 언어.

고급언어 vs 어셈블리어
오래전에는 어셈블리어가 빠를 수 있었지만 지금은 컴파일러 성능이 비약적으로 발전하고 CPU도 복잡해졌습니다.
컴파일러들은 능숙하게 최적화된 코드를 생성해냅니다.
변수 선언만하고 사용하지 않으면 전혀 생성하지도 않습니다.
루프 횟수가 적고 단순하면 그냥 코드를 반복해 생성하기도 합니다.

*/