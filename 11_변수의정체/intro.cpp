/*
변수의 선언이 가지는 의미는 무엇인가요?
변수가 선언되면 컴파일러는 내부적으로 선언된 변수에 대해 사용할 준비를 하게 됩니다.
메모리 어느 위치에 위치시킬지, 테이블에 기록한다든지의 과정.
하지만 프로그래머가 변수를 사용하지 않으면 컴파일러는 코드로 변환하지 않습니다.

포인터변수와 일반 변수의 차이점은 무엇인가요?
포인터 변수도 int변수처럼 정수값을 저장해서 다른 변수처럼 사용할 수 있습니다.
단지 포인터 변수만이 할 수 있는 것은 *연산자를 통해 포인터 변수의 값을 읽고, 
읽은 값을 메모리 주소로 보고 해당 메모리 주소의 값을 다시 액세스할 수 있는 '간접 액세스'를 지원하는 것.

01 약방의 감초 - 변수
아무리 간단한 프로그램을 만들려 해도 변수가 없다면 구현이 힘듭니다.

02 변수의 종류와 선언
표준 변수
         char 문자/정수 8비트 -128~127
unsigned char 정수      8비트 0~255
        short 정수     16비트 -32768~32767
unsigned short 정수    16비트 0~65535
         long 정수     32비트 -2147483648~2147483647
        float 실수     32비트 1.2E-38~3.4E+38
       double 실수     64비트 2.2E-308~1.8E308
  long double 실수    128비트 3.4E-4932~1.2E4932
각각에 대해 포인터타입도 있고 모아서 나타내는 구조체(structure)형태도 있다.
변수란 어떠한 값을 담아두는 그릇과 같다.
변수는 CPU의 가장 기본적인 저장 장치인 레지스터가 될 수도 있고, 외부에 메모리일 수도 있다.
이런 자원은 한정적.
이런 유한한 자원을 효율적으로 사용하기 위해서는 용도에 맞는 크기의 변수를 사용해야 합니다.
int val;
return 0;
val이라는 int형 변수만 하나 선언하고 바로 종료되는 프로그램.
break point가 잘못된 라인에 설정되 다음 유효한 라인으로 옮겨진다.
int val = 1;
return 0;
잘 진행된다.
결론적으로 C코드는 그 자체로는 CPU가 알아볼 수 없고, 어셈블리 코드로 바뀌고 최종적으로
CPU의 인스트럭션으로 변환 후 실행합니다.
break point를 설정하면 우선 컴파일러가 코드 전체를 컴파일해서 최종적으로 인스트럭션으로 변환하고,
break point가 설정된 곳의 코드에 해당하는 인스트럭션상에서 브레이크를 거는 것.
하지만 val변수를 선언만 한 경우에는 실질적으로 어떤 인스트럭션으로도 변환하지 않았다는 것을 의미.
변수를 선언하는 자체는 CPU 입장에선 어떤 동작도 할 필요가 없다는 것을 의미.
C에선 변수를 사용하려면 우선 선언이라는 과정을 해야하지만
어셈블리나 인스트럭션으로 프로그램을 작성할 때는 이런 변수 선언 과정이 없습니다.
왜냐면 메모리나 레지스터 전체가 이미 선언된 변수나 다름없기 때문.
마음대로 임의의 메모리나 레지스터에 원하는 값을 쓰거나 읽을 수 있는데 변수를 액세스하는 과정이다.
대신 직접 메모리를 액세스하여 어셈블리로 작성하면 주의를 기울여서 사용해야 합니다.
C에서 변수 선언을 하는 것은 C컴파일러에게 임의의 비어있는 메모리를 확보하라고 알려주는 것.
즉, 비어있는 변수크기만한 영역의 주소를 기억하고 있다가 해당 변수에 값을 쓰거나 읽으면 그 영역을 대상으로 동작.
변수선언 자체는 단지 컴파일러에게 어떤 크기의 메모리 공간 주소를 선정해 기억해달라고 요청하는 것.
대입을 같이하면 변수 선언 때 컴파일러가 선정하게 된 메모리 영역에 실질적으로 값을 쓰는 것.
따라서 STORE 같은 인스트럭션으로 변환되고, break point가 걸린다.
브레이크 포인트 부분에서 Ctrl+Alt+D을 누르면 디스어셈블리 윈도우로 볼 수 있다.
int main() {
00AC16E0 55                   push        ebp
00AC16E1 8B EC                mov         ebp,esp
00AC16E3 81 EC CC 00 00 00    sub         esp,0CCh
00AC16E9 53                   push        ebx
00AC16EA 56                   push        esi
00AC16EB 57                   push        edi
00AC16EC 8D BD 34 FF FF FF    lea         edi,[ebp-0CCh]
00AC16F2 B9 33 00 00 00       mov         ecx,33h
00AC16F7 B8 CC CC CC CC       mov         eax,0CCCCCCCCh
00AC16FC F3 AB                rep stos    dword ptr es:[edi]
00AC16FE B9 00 B0 AC 00       mov         ecx,offset _7B510B62_test.cpp (0ACB000h)
00AC1703 E8 F6 FA FF FF       call        @__CheckForDebuggerJustMyCode@4 (0AC11FEh)
	int val;
	return 0;
00AC1708 33 C0                xor         eax,eax
}
00AC16XX이 번역된 인스트럭션이 차지하는 메모리 어드레스를 나타냅니다.
그 다음에 있는 일련의 16진수 값들이 인스트럭션 부분이고 그 다음 것이 어셈블리 표기.
바이트가 들쑥날쑥한 것도 CISC의 특징.
명령어를 여러 종류를 만들어 최대한 하드웨어적인 지원을 해주고, 동시에 이러한 명령어를
최대한 짧게 유지할 수 있도록 길이를 가변으로 만들어 효율을 높이고자 한 방식.
대신 복잡해지는만큼 처리 속도가 늦어지기 때문에 결국 단순하면서 빠르게 하려 RISC쪽으로.
인텔도 슈퍼스칼라 방식으로 RISC개념을 도입했지만 하위 CPU와의 호환성을 위해
인스트럭션 Set자체는 복잡한 구조를 유지하고 있다.
main함수 시작부분에는 함수 호출시 필요한 스택을 셋업하고 관련 레지스터들을 보존하는 작업을 위해
모든 함수의 초입 부분에 존재하는 코드.
int val;선언부에는 어셈블리 코드로도 번역되지 않고 그냥 비어있다.
그래서 브레이크 포인트도 return 0;으로 밀림.
xor eax,eax는 eax라는 레지스터 두 개를 서로 xor해서 다시 왼쪽의 레지스터에 저장하라는 의미인데,
eax레지스터가 리턴값으로 사용하는 레지스터이다.
똑같은 값을 서로 xor을하면 0이 된다.
val이라는 변수를 선언하면서 1을 대입하면
mov dword ptr [ebp-4],1
mov는 메모리나 레지스터의 값을 옮기기 위한 인스트럭션이고 오른쪽 오퍼랜드 값을 왼쪽으로 옮김.
1이라는 상수값을 왼쪽의 dword ptr [ebp-4]로 옮김.
이제 1이라는 값을 val이라는 변수가 나타내는 메모리로 옮기는 것.
따라서 왼쪽의 dword ptr [ebp-4]는 val변수를 나타내는 것.
ebp는 CPU내부의 많은 레지스터 중 하나고 이 레지스터가 가리키는 메모리 주소보다 4작은 곳에 기록하라는 명령.
dword ptr은 메모리를 상대로 읽기나 쓰기를 할 때 해당 메모리 주소로부터 얼만큼의 크기를 대상으로 삼을지 결정.
즉 4바이트 크기의 공간에 1을 대입하라는 의미.
ebp-4라는 메모리 주소가 val이라는 변수 영역으로 선정된 것이고 이 곳에 1이라는 값을 저장한 것.
int val = 1;
int val; val = 1;
나누어져 있을 뿐이지 실제 어셈블리 코드는 완전히 같다.
변수의 선언 자체는 어떤 의미도 없고, 필요한 크기의 메모리 공간을 컴파일러가 인지하게 하고,
그 메모리 공간을 대상으로 실제 값을 읽고 쓰는 작업이 일어나는 것.

03 변수의 크기와 부호
변수의 범위는 같은 크기의 변수여도 양수만 사용하는 unsigned냐 음수까지 커버하는 signed냐에 따라 달라진다.
char val = 127;
컴파일러는 정확히 1바이트 공간에 127이라는 숫자를 저장한다.
intel CPU에는 'byte ptr'이라는 키워드가 있는데 CPU가 바이트 단위 오퍼레이션을 위해 특별한 인스트럭션.
제공하지 않는다면 해당 CPU의 컴파일러가 다른 형태로 인스트럭션을 나열해 같은 기능을 구현.
16비트 단위로만 메모리를 액세스하는 CPU의 경우 미리 저장할 메모리주소에서 16비트 데이터를 레지스터로
읽어온 다음, 레지스터의 상위 바이트를 다시 상수값으로 치환한 다음 이를 메모리에 저장할 수도 있다.
만일 메모리에 0x12, 0x34가 나란히 저장되어 있을 때 0x12만 127로 바꾸자하면
LOAD  R1,[Mem] #R1 = 0x1234
LUI   R1,127   #Load Upper Immediate
		       #Now R1 = 0x7F34
STORE R1,[Mem] #[Mem] = 0x7F34
intel에서는 mov하나로 해결될 것인 mov byte ptr같은 키워드가 없는 CPU에서는 위와 같이 늘어나
느려질 것 같지만 실제로 그렇진 않습니다.
한 인스트럭션당 수행되는 시간이 짧아 결과적으로 더 빠르거나 비슷할 수도 있는 것.
C코드에서는 메모리상에 값만 한 바이트 바뀐것.
-1을 넣으면 0xFF가 기록됨.
크기를 초과하면 컴파일러가 알아서 변수 크기에 맞추어 상수값을 자릅니다.
char val = 300;
어셈블리로 보면
move byte ptr [ebp-4],2Ch로 표현되고 0x2C와 같다. (0x12C->0x2C)
변수 크기를 어떻게 선언하냐에 따라 원하지 않은 값이 메모리에 저장될 수 있으므로 적절한 변수크기는 중요하다.

값들을 비교하려면 비교하려는 값 모두가 메모리가 아닌 레지스터에 있어야 합니다. 연산도 마찬가지.
메모리가 개입한 연산용 인스트럭션은 없는 경우가 대부분. 느린 메모리 속도 문제 때문.
Add라는 연산을 하려면 ALU의 양 입력에 두 오퍼랜드값을 주고 ALU가 Add를 하도록 컨트롤 시그널을 줘
한 클럭안에 연산 결과가 저장되도록 설계합니다.
하지만 곧바로 메모리에 접근을 하면 느린속도 때문에 한 클럭안에 끝내기 힘듭니다.
전체 속도에 지장을 주므로 레지스터를 대상으로 연산을 하고 필요할 경우 다시 메모리로 옮기는 방식.
127이라는 상수와 val이라는 변수를 비교하려면 val이라는 변수를 메모리에서 읽어 레지스터로 옮겨야하는데,
상수를 메모리로 옮길 때와 마찬가지로, 변수의 크기에 맞춰 옮겨야 합니다.
이를 위해 똑같은 byte ptr 키워드를 사용하여 변수가 가리키는 메모리에서 몇 바이트를 읽을지 결정.
상수를 메모리로 옮길 때는 크기만 고려했지만 메모리의 값을 레지스터로 옮길 때는 부호도 신경써야합니다.
만약 0xFF가 있으면 레지스터로 불러올 때 레지스터크기가 32비트라면 4바이트 포맷에 맞게 확장해야 합니다.
그런데 이 때 확장하는 수가 음수냐 양수냐에 따라 방법이 달라집니다.
양수인 경우에는 앞 쪽비트가 모두 0이지만 음수일 경우 1이 되야하는 것.
0xFF는 -1로도 해석할 수 있고 255로도 해석할 수도 있어 0x000000FF or 0xFFFFFFFF
Intel에서는 이를위해 하드웨어적으로 인스트럭션 Set을 다르게 지원합니다.
메모리의 값을 무조건 양수로 취급하여 레지스터로 옮길 경우는 그냥 movzx라는 인스트럭션.
부호를 고려한 숫자일 경우 movsx라는 인스트럭션.
movzx eax, byte ptr [ebp-4] #eax = 0x000000FF
movsx eax, byte ptr [ebp-4] #eax = 0xFFFFFFFF
VC++컴파일러에서 직접어셈블리 코드를 작성하려면 __asm이라는 키워드 사용.
__asm {
	movbyte ptr [ebp-4], 0xff
	movzx eax, byte ptr [ebp-4] //eax = 0x000000FF
	movsx eax, byte ptr [ebp-4] //eax = 0xFFFFFFFF
	mov dword ptr [ebp-4], eax //제일 처음 eax로 선언된 int 변수의 메모리 공간에 해당
	mov dword ptr [ebp-8], ecx //제일 처음 ecx로 선언된 int 변수의 메모리 공간에 해당
};
결론적으로 메모리의 데이터가 음수인지 양수인지에 따라 사용해야 하는 인스트럭션이 바뀐 것.
음수인지 양수인지는 변수 타입 unsigned인지를 확인해 결정하는 것.
메모리 데이터가 레지스터로 로드되면 이 값과 상수 127을 비교해야 합니다. 대개 CPU는 비교인스트럭션 제공.
cmp인스트럭션은 두 오퍼랜드 간의 빼기 연산을 합니다 그리고 결과에 따라 플래그 값을 설정합니다.
0이 되었을 경우엔 Z라는 플래그 값이 1로 set.
음수인지 양수인지 따라서 S라는 플래그 값이 1이나 0으로 set.
조건 분기 인스트럭션들은 이런 플래그를 보고 분기 여부를 결정하는 것.
mov byte ptr [ebp-4],0x7F #Mem[ebp-4] = 0x7F
movsx eax,byte ptr[ebp-4] #eax = 0x0000007F
cmp eax,0x7F              #Z = !(eax-0x7F)
jne NEXT_CODE             #if Z != 1 goto NEXT_CODE
NEXT_CODE:
Z플래그가 1로 셋팅되고 참이 된다.
unsigned char로 바꾸게 되면 movzx대신 ebp-4의 메모리 주소에서 1바이트를 가져오지 않고 4바이트를 가져와
0xFF와 and함으로써 상위 3바이트를 0으로 만들어버립니다.
즉, movzx를 쓸 때와 마찬가지 결과를 내는 것.
데이터 시트에는 movzx로 8비트의 메모리 데이터를 32비트의 레지스터로 확장이동하는 데 걸리는 시간은 6클럭.
mov 인스트럭션으로 32비트 메모리 데이터를 32비트 레지스터로 옮기는데 4클럭걸리고 and하는데는 2클럭.
그러므로 실질적인 속도 차이는 없다.
RISC CPU였다면 모든 인스트럭션이 한 클럭에 수행되므로 하나의 인스트럭션으로 만드는 것이 빠를 것.
Intel에서는 인스트럭션 수를 늘려 프로그램의 효율을 높인 것.
복잡해졌기 때문에 각 인스트럭션마다 수행 시간이 달라진 것.

val = 128;인 경우 0x80이어야 한다.
mov byte ptr [ebp-4],0x80으로 번역 되어야 하고 movsx인스트럭션을 통해 [ebp-4]번지의 1바이트를
32비트로 부호 확장하여 레지스터에 저장하고 조건 분기문을 완성할 것입니다.
하지만 부호를 고려한 1바이트 변수인 char에서는 가장 첫 번째 비트가 1이므로 음수값 -128로 판단.
32비트로 확장할 경우 여전히 -128을 나타내야 하기 때문에 앞을 모두 1로 채우게 된다.
그래서 0x000000F0이 아닌 0xFFFFFFF0이 되는 것.
128이 아니므로 Z플래그가 0으로 셋팅.
ZR이라는 값이 Z플래그 값.
unsigned char로 바꾸어 선언하면 잘 수행된다.

04 양날의 칼 - 포인터
익히고 사용하기 어렵긴 하지만 일단 익히고 나면 유용합니다.

int와 닮은 포인터 변수 - 포인터 변수를 통한 덧셈
CPU도 중간중간 인터럽트가 들어올 때는 잠시 다른일을 하기도 합니다.
깔끔하게 구획을 나누어 정리하는 사람은 고급 컴파일러.
알아보기 쉽고, 정리는 잘 되지만 크기를 잘모산누면 낭비되는 공간도 있다.
적당하게 빈 공간에 메모를 적는 것은 어셈블러 혹은 인스트럭션 레벨에서 직접 프로그램을 만드는 것.
컴파일러는 메모리의 사용 영역을 명확히 구분하고 변수를 이름으로 기억해 찾기 쉬움.
어셈블러는 용량도 작고 빠른 효율적인 프로그램이지만 복잡해지고 위치를 기억하기 어려움.

포인터는 일반변수와 같다.
int a = 10;
int b = 20;
int c = a + b; //30
int *a = (int*)10;
int *b = (int*)20;
int *c = (int)a + (int)b; //30
메모리의 어느 공간 세 곳을 선정하여 a,b,c라는 이름으로 C컴파일러가 기억하고 있다가
메모리 공간에 각각 10, 20, 30이라는 값을 적어 두는 것과 같다.
int로 선언하게 되면 각 변수마다 4바이트 공간을 확보하는 것.
포인터 변수란 사실 다른 변수와 마찬가지로 메모리 한 부분에 원하는 값을 기록해두고 나중에 사용.
단지 차이가 나는 것은 크기와 사용 용도.
크기는 변수를 선언함과 동시에 컴파일러가 정해진 크기만큼 메모리를 확보하고 용도는 얼마든지 임의로.
char변수는 주로 글자를 저장하기 위해 사용하지만 글자로 취급할지 숫자로 취급할지는 프로그래머에게.
예를 들어 16진수 값을 숫자로 바꾸는 코드.
16진수 값을 연산할 경우 이 자체는 숫자가 아니므로 숫자로 변환해야 합니다.
15 = ('f' - 'a') + 10 = ('F' - 'A') + 10
9 = ('9' - '0')
48 = '0' 
65 = 'A'
97 = 'a'
포인터 변수 역시 4바이트라는 크기만 정해져 있을 뿐 어떤 값을 저장하는 메모리 공간에 불과.
단지 표준 C에서는 포인터 변수와 상수간의 연산은 정의, 포인터 변수간의 연산자는 정의되어 있지 않으므로 캐스팅.
포인터는 형과 상관없이 4바이트의 정수를 담는 변수.
형선언은 새로운 변수 형을 선언해서 컴파일러에게 알려주는 것.
typedef int* INTP;
INTP a = (INTP)10;
INTP b = (INTP)20;
int c = (int)a + (int)b;
포인터 변수는 단지 어떤 숫자 값(주로 메모리주소)을 저장하는 변수라는 것만 알자.
*연산자는 변수명 앞에 붙임으로써 해당 변수가 포인터로서의 역할을 할 수 있게 해줌.
그 변수의 값을 단순한 숫자가 아니라 메모리의 특정 주소로 인지하여 그 주소의 메모리 값을 액세스 하는 것.
보통 변수는 그 변수 자체가 직접 어떤 메모리 공간을 대표하는 반면,
포인터 변수를 통한 액세스는 그 변수 값을 통해 다시 한번 메모리를 액세스하므로 간접 액세스 방식.
int *pMyPtr = (int*)0x100; //대입
*pMyPtr = 123; //pMyPtr변수를 우선 액세스해서 0ㅌx100이라는 값을 읽고 그 주소에 123을 기록.
|0x100|ㄱpMyPtr(4Bytes)
|     |
| 123 |ㄱ0x100(4Bytes)
최종 목적은 0x100번지 메모리에 123이라는 값을 쓰는 것.
우선 pMyPtr이라는 포인터 변수를 선언해 액세스하고자하는 0x100을 대입.
C컴파일러는 0x100이라는 상수정수를 int형으로 취급해 타입이다르다고 생각하기 때문이 (int*)캐스팅.
0x100번지에 간접 액세스하기 위해 *연산자를 pMyPtr변수에 적용해 원하는 값 123을 대입.
int*는 pMyPtr을 통해 간접 액세스를 할 때 액세스되는 메모리의 크기를 결정하는 역할.
여전히 포인터 변수의 크기는 4바이트
포인터변수형이 바뀌는 것은 메모리를 간접 액세스되는 메모리의 크기가 바뀐다는 것을 의미.
|0x100|ㄱpMyPtr(4Bytes)
|     |
| 123 |ㄱ0x100(1 or 2 or 4Bytes)
*연산자는 변수값을 주소로 인식해 간접 액세스할 수 있는 유일한 변수.
정리해보면
1)포인터 변수는 일반 정수형 변수와 같다. 대입할수도 읽을수도 연산할 수 있다.
2)포인터 변수는 타입과 상관없이 항상 4바이트 크기를 가지는 정수형 변수.
3)포인터 변수는 *연산자를 사용해 변수값을 메모리주소로 하여 간접 액세스를 지원하는 유일한 변수.

typedef int* INTP;
INTP *ppPtr;
ppPtr = (INTP*)0x100;
*ppPtr = (INTP)123;
포인터말고 다른 변수종류라고 인식해보자.
특정한 주소의메모리를 INTP형태로 간접 액세스하기 위해 포인터를 선언하려 한다.
0x100번지를 액세스해서 123이라는 값을 대입하기 위해 ppPtr변수에 0x100을 대입.
하지만 타입이 다르므로 (INTP*)형태의 캐스팅.
0x100번지에 123이라는 값을 대입하기 위해 *연산자를 ppPtr에 적용.
ppPtr은 INTP형의 포인터 변수이므로 *연산자를 사용해 액세스되는 메모리는 INTP형 데이터로 캐스팅.
즉, 이중 포인터는 새로운 변수 형인 '포인터 변수'의 포인터 변수.
int i, *pi, **pi;
i = 100;
pi = &i;
ppi = &pi;
정수형 변수 i를 선언하고 100이라는 값을 넣음.
pi는 변수 i의 포인터 변수, ppi는 포인터변수 i의 포인터 변수.
|1245052|ㄱ1245048. pi
|       |
|  100  |ㄱ1245052. i
|       |
|1245048|ㄱ???????. ppi
*pi = i, **ppi = i, *pi = p
변수가 선언되면 컴파일러는 각 변수에게 적절한 메모리 공간을 할당합니다.
C에서는 *연산자와 함께 변수의 주소를 알기 위한 &연산자를 제공.
&연산자는 변수 앞에 붙게 되면 해당 변수의 메모리 주소를 리턴.
pi = &i는 i변수의 주소값이 pi변수값이 되는 것.
ppi변수의 값을 pi메모리 주소값이고 pi의 값은 i변수가 위치한 메모리의 값.
각 포인터 변수에 *연산자를 취하면, 해당 포인터 변수의 값을 주소로 인식해 그 주소에 있는 메모리를 액세스.

05 함수까지 가리키는 만능 재주꾼 - 포인터
정리해보면
1)컴퓨터는 기본적으로 0과 1밖에 기억할 수 없는 장치.
2)컴퓨터는 2진수 숫자를 기억해 여러 작업을 하는 장치.
3)여러작업은 프로그램을 의미하고, 숫자를 기억하는 메모리 공간을 변수라고 한다.
4)변수는 숫자를 기억하는 메모리의 한 공간
5)포인터 변수도 변수다
6)포인터 변수도 '숫자'를 기억하는 메모리 공간.
7)일반변수로 할 수 있는 모든 것을 포인터로 할 수 있다.
8)포인터만이 할 수 있는 것은 *연산자를 통해 포인터 변수의 값을 읽고, 그 읽은 값을 메모리 주소로
보고 해당 메모리 주소의 값을 다시 액세스할 수 있는 '간접 액세스'를 지원.

변수는 그냥 어떤 값을 저장하는 공간일 뿐이고 그 값을 어떻게 활용하는냐는 프로그래머에 따라.
간접 액세스 이외에도 특정 함수의 코드 주소를 가리키게 하는 것을 할 수 있습니다.
함수도 코드의 집합에 불과합니다.
이름을 붙이고 코드덩어리를 메모리 어딘가에 배치한 후 필요한 곳에서 이 주소로 점프하여 수행하는 것.
void형의 리턴타입을 가지는 함수는 리턴값이 없으므로 서브루틴과 동일.
함수를 호출하는 과정은 그냥 함수 코드가 있는 주소로 점프하는 것.
단지 인자를 전달하고 함수의 수행이 끝나면 다시 점프한 위치로 되돌아오게 하는 매커니즘이 필요.

void MyFunc() {
	getch();
}
int main() {
	int nAddr;
	nAddr = (int)MyFunc;
	__asm {
		jmp dword ptr [ebp-4]
	}
	printf("");
	getch();
	return 0;
}
getch함수에 의해 키 입력을 기다리는 상태.
C가 고급언어이면서 동시에 저급언어적 성격을 띠며 어플리케이션과 임베디드 시스템에도 좋은이유가 __asm키워드.
__asm은 C코드 중간에 직접 어셈블리 인스트럭션을 삽입할 수 있는 기능.
함수를 호출하면서 괄호도 없고, 리턴 타입도 void이지만 nAddr은 int변수로 리턴값을 받고 있습니다.
이것은 MyFunc함수를 호출하는 것이 아닌 MyFunc함수의 시작 주소를 얻는 것.
함수는 하나의 서브루틴이고, 각 함수의 이름은 서브루틴의 시작 주소를 나타냄.
이름과 함께 인자값을 넘기면 자동으로 C컴파일러는 인자를 넘기는 작업과 함께 해당 함수
주소로 점프하는 코드를 그 위치에 삽입하는 것.
괄호 없이 그냥 함수이름만 쓰면 C컴파일러는 이를 호출이 아닌 함수의 시작 주소로 인식.
함수의 시작주소는 메모리 공간상의 어떤 주소값이다.
그리고 얻은 함수의 주소로 점프한다면 함수를 호출하는 것 같은 효과를 얻을 수 있다.
특정 주소로 점프를 하는 어셈블리 인스트럭션이 jmp dword ptr[ebp-4].
ebp라는 레지스터 값에서 4바이트를 뺀 값을 4바이트 단위로 참조하라는 것.
ebp-4번지의 값이 바로 함수 안에서 사용된 지역변수의 주소입니다.
nAddr변수는 MyFunc함수의 시작 주소값을 나타내고 jmp로 nAddr변수가 가리키는 주소로 점프하면 함수가 실행.
즉, 함수호출을 하는 것과 같다.
그런데 getch에서 입력을 기다리다가 문자가 입력되면 MyFunc는 종료되고 jmp인스트럭션 이후 
코드가 수행되어 printf가 수행되야 하는데 그렇지 못하고 에러 창을 띄우고 종료하게 됩니다.
이유는 MyFunc함수 이후 다시 점프한 지점으로 되돌아오는 매커니즘을 지키지 못했기 때문.
함수를 호출한 지점으로 되돌아오기 위해서는 함수를 호출할 때 인자들과 함께 리턴할 지점의 주소도 함께
전달해줘야 하는데, 수동적으로도 할 수 있지만 Intel에서는 call이라는 인스트럭션이 작업을 해줌.
즉, 리턴할 주소를 저장하고 jmp처럼 해당 주소로 점프하는 것.
그러므로 jmp있던 자리에 call로 바꿔주어야 한다.
C에서는 ebp-4와 같이 직접 메모리 주소를 나타내지 않고 nAddr을 직접기재하면 컴파일할 때 해당 주소를 삽입해줌.
그래서 call dword ptr[ebp-4] 대신 call nAddr로 바꿀 수 있다.
컴파일하면 nAddr의 주소가 dword ptr[ebp-4]로 번역되어 있다.
call대신 jmp인스트럭션을 사용해 버그를 만들기도 했다.
리턴값이나 인자까지 더 들어가려면 자세한 함수 호출 매커니즘을 알고 어셈블리 코드를 작성하지 않고도
함수를 호출할 수 있는 방법이 함수 포인터 변수.
nAddr이 int형 변수가 아니라 함수 포인터로 선언된 변수라면 훨씬 더 간단.
함수 포인터로 선언된 변수는 함수의 호출 매커니즘을 몰라도 해당 함수의 주소로 매커니즘에 맞춰 호출하게 해줌.
void MyFunc() {
	getch();
}
int main() {
	void (*nAddr)();
	nAddr = MyFunc;
	nAddr();
	printf("");
	getch();
	return 0;
}
nAddr은 포인터 변수이기 때문에 *기호가 있고 리턴형은 void이고 인자가 없으므로 그냥()형태로 선언.
nAddr변수에 MyFunc의 시작주소를 대입하고 함수를 호출하듯 nAddr();
하지만 직접호출하는 것과 차이가 있습니다.
	MyFunc();
00EB18AF E8 9A F9 FF FF       call        _MyFunc (0EB124Eh)
	nAddr();
00EB18B4 8B F4                mov         esi,esp
00EB18B6 FF 55 F8             call        dword ptr [nAddr] //[ebp-8]
00EB18B9 3B F4                cmp         esi,esp
00EB18BB E8 5C F9 FF FF       call        __RTC_CheckEsp (0EB121Ch)
MyFunc를 직접 호출하는 경우는 0EB124Eh라는 주소를 직접 call하는 반면 함수포인터를 사용해 호출하면
우선 nAddr의 값을 읽고 이 값을 주소로 삼아 call합니다.
그리고 앞뒤에 인스트럭션이 더 붙는데, 스택 프레임을 체크하는 부분이 있습니다.
포인터변수처럼 함수포인터변수를 사용해 함수의 시작주소로 간접 호출하는 것과 같은 것.
인자와 리턴값을 넣어 선언하려면
double (*nAddr)(int);
fRet = nAddr(200);
선언하는 부분만 리턴타입과 인자부분을 수정하고 호출할 때는 여전히 함수 호출 방식으로 사용하고 있다.
정적인 변수들과는 달리 포인터의 주된 사용 용도는 동적인 메모리 할당이 주목적.
선언하고 사용하는 변수들은 프로그램을 작성하는 시점에서 이미 그 크기가 정해져야 하지만,
사용자의 입력에 따라 동적으로 데이터가 늘어나고 공간도 늘어나야되면 malloc과 같은 동적할당함수를 사용해 
메모리를 할당하고 포인터 변수를 통해 이를 액세스합니다.
함수 중에는 동적 변수와 같이 컴파일 시에 작성되는 것이 아니라 프로그램을 실행하다가 생성되는 함수도 있습니다.
DLL같은 것으로 동적 라이브러리.
라이브러리는 미리 자주 쓰이는 함수 등을 만들어 놓고 프로그램을 작성하다가 필요할 때마다 불러 쓰는 것.
필요할 때 불러쓰면 그 함수의 코드가 실행파일에 첨부되는 것.
이런 과정은 소스 코드를 컴파일할 때 자세히는 링크과정에서 일어나는 것.
프로그램이 실제 실행될 때가 아니라 작성하고 컴파일할 때 코드가 합쳐지는 작업이 일어나는 것.
그래서 실행되는 시점에서는 이미 함수 코드가 메모리상에 존재하고 main에서 점프해서 함수호출했던 것.
정적 라이브러리를 통한 링크 과정
코드 ---> obj파일 + printf를 포함한 라이브러리 ---> 실행파일
    컴파일

하지만 DLL같은 동적라이브러리는 다릅니다.
미리 누군가에 의해 작성되어 컴파일된 라이브러리이지만 컴파일 시점에서 프로그램에 합해지지 않습니다.
대신 실행되는 동안 프로그램안에서 LoadLibrary라는 윈도우즈API함수를 사용해 DLL을 메모리에 로드한 후,
동적으로 함수를 찾는 것. 그리고 이 때 함수 포인터가 필요합니다.
printf가 DLL형태로 제공됐다면 막 부를 수 없었을 것이다.
왜냐면 링커가 코드를 링크하는 시점에서 printf에 대한 코드를 찾을 수 없기 때문.
printf를 호출해야할 시점보다 미리 LoadLibrary를 통해 필요한 DLL을 로드하도록 코드를 작성하고
함수 포인터 변수를 만들어 이 변수가 새로 로드된 printf함수를 가리키게 해야 합니다.
그리고 함수 포인터를 통해 간접 호출을 하는 것.
실행 중 동적으로 DLL을 로드한 후 함수 포인터를 통한 printf함수의 호출 과정
main() {
	LoadLibrary(...);
	pPt = GetProcAddr(.."printf");
	pPt("...",...);
}
코드 ---> 실행 파일 실행 ---> 빈메모리에 printf함수 코드가 로드 됨 ---> GetProcAddr 후 pPt는 새로 로드된
  컴파일&링크      LoadLibrary실행                                   printf함수의 코드 시작주소를 가리킴.
                                                                   이후 pPt를 통해 printf호출 가능.

윈도우즈에서는 LoadLibary와 함께 GetProcAddr이라는 API함수를 제공해서 이 API함수를 통해 동적으로 로드된
라이브러리에서 필요한 함수를 이름으로 찾습니다.
그리고 찾은 함수의 시작 주소를 함수 포인터 변수에 맵핑해서 자유롭게 호출할 수 있는 것.

함수 포인터 변수의 용도는 콜백(Call Back)함수로도 많이 이용됩니다. 대표적으로 qsort함수.
void qsort(void *base, size_t num, size_t size, int (*comp_func)(const void*,const void*))
함수 포인터를 인자로 요구하는 이유는 정렬할 때 정렬의 기준을 삼기 위해서입니다.
qsort는 아주 범용적인 함수로 정렬의 대상이 되는 값이 정수나 문자열 등 어떤 데이터 타입이 될 수도 있습니다.
따라서 정렬을 필요로 하는 대상이 배열 형태로 메모리에 있다고 가정하고 base에 배열의 시작주소를 인자로 받습니다.
그리고 배열에 들어있는 정렬할 대상의 개수와 크기를 각각 num, size인자로 받는다.
정렬 대상 객체를 어떻게 판단해 정렬할지를 마지막 인자로 받은 콜백 함수를 통해 판단합니다.
qsort를 부를 때는 정렬 대상의 우선순위를 결정하는 비교함수를 만들고 이 함수의 주소를 인자로 넘긴다.
qsort함수를 이용해 정수 값을 오름차순으로 정렬하는 예제.
#include <stdlib.h>
#include <conio.h>
#include <stdio.h>

int compare_ints(const void* a, const void* b) {
	int* arg1 = (int*)a;
	int* arg2 = (int*)b;

	if (*arg1 < *arg2)
		return -1;
	else if (*arg1 == *arg2)
		return 0;
	else
		return 1;
}

int main(int argc, char* argv[]) {
	int array[] = { -2,99,0,-743,2,3,4 };
	int array_size = 7;
	int i;

	printf("Before sorting:");
	for (i = 0;i < array_size;i++) {
		printf("%d ", array[i]);
	}
	printf("\n");

	qsort(array, array_size, sizeof(int), compare_ints);

	printf("After sorting:");
	for (i = 0;i < array_size;i++) {
		printf("%d ", array[i]);
	}
	printf("\n");

	getch();

	return 0;
}
compare_ints가 비교를 행하는 함수인데 첫번째 인자가 두번째 인자보다 앞쪽에 위치해야 음수값을 아니면 양수리턴.
같은 우선 순위를 가지고 있다면 0을 리턴.
qsort는 내부적으로 정렬 대상들을 비교할 때마다 이 비교 함수를 호출해서 그 결과값으로 판단합니다.

06 포인터의 함정 - 댕글링 포인터
포인터라는 건 구체적인 메모리 주소를 통해 대상을 액세스할 수 있게 해준다는 점에서 편리하다.
자유로운 특징으로 인해 그만큼의 책임을 지게 된다.
가장 문제가 되는 것이 잘못된 주소에 대한 참조.
가리키고 있는 주소가 의도하지않은 주소던가 변경하면 안되는 주소이면 심각한 문제에 직면할 수도.
이런 유효하지 않은 주소를 가리키고 있는 포인터를 댕글링 포인터(Danggling Pointer)라 부릅니다.
malloc을 이용해 동적으로 메모리를 할당받고 free로 메모리를 해제하면 포인터는 유효하지 않은 상태.
포인터 변수는 주소값을 담아두는 변수이고 메모리를 해제하였다하더라도 주소값을 담고 있다.
무심코 이 포인터 변수를 통해 값을 읽거나 쓰면 문제가 생길 수 있다.
이를 방지하기 위해서는 일반적으로 NULL 포인터 사용.
메모리 주소 중 0번지 주소는 어떤 다른 용도로 사용하지 말고 포인터가 무효한상태임을 나타내자.
그래서 포인터는 0으로 만들어 이후 포인터를 사용할 때마다 0인지 체크한 후 사용하는 것.
그리고 0이라는 값에 특벼한 별명을 준 것이 NULL.
int* pInt = NULL;
pInt = malloc(100);
if (pInt != NULL) {}
free(pInt);
pInt = NULL;
최초에 포인터 변수를 선언하고 바로 NULL, 0으로 만들어 아직 무효한 포인터라는 것을 나타냄.
이후 malloc을 통해 실제 유효한 메모리를 가리킨 이후에도 포인터를 사용할 때는 NULL인지 확인하고 사용.
마지막에 메모리를 해제하고나서는 포인터 자체도 NULL로 만들어 무효한 포인터로 만드는 것.

07 일반 포인터
포인터가 4바이트의 크기를 가지는 것은 CPU가 32비트 CPU이기 때문.
CPU내부의 레지스터가 32비트크기이고, 이 레지스터를 통해 메모리 주소를 액세스하다보니 포인터도 4바이트.
최신 64비트 컴퓨터에선 8바이트의 크기를 가진다는 것.
데이터 형과는 관계없는 작업을 하는 경우 예를 들어 메모리 특정 주소에서 다른 주소로 100바이트만큼복사.
이미지 데이터를 가공하기위해 메모리로 로드하고 다시 화면에 뿌리려고 비디오 메모리로 옮긴다던지 할 때.
분명 메모리 주소를 이용해 복사해야 하므로 포인터가 필요하긴 한데 '아무 형이나 상관 없다'
포인터의 Type은 *연산자로 간접 액세스하여 그 값으로 연산을 할 때 필요하지 데이터복사에선 의미 없음.
아무 형으로나 포인터 변수를 선언하고 이 포인터 변수의 값을 이용해 메모리 복사를 하면 됩니다.
포인터가 아닌 int변수를 선언해도 괜찮다.
memcpy는 복사하고자 하는 소스 데이터 주소와 타겟데이터 주소, 복사하려는 데이터길이를 바이트단위로 받아
두 메모리간의 복사작업을 수행한다.
인자로 주소값을 두 개 받아야하는데 아무 Type이나 상관은 없습니다.
하지만 데이터 형이 일치하지 않으면 warning에러가 있다.
warning에러는 사용하는데는 문제는 없을 것이다 하지만 이런 경우를 대비해서 특정한 형이없는
포인터를 마련해두고 있습니다. void pointer(void*)
void 포인터 변수는 memcpy같은 경우를 위해 사용되는 포인터 변수.
컴파일러에게 void로 선언된 포인터 변수엔 어떤 포인터 형을 대입해도 에러내지 말라고 하는 것.
하지만 void형은 *를 통해 메모리를 액세스할 수도 없습니다. 
특정한 형이 지정되어 있지 않기 때문에 몇바이트 데이터인지 모르기 때문.
그래서 void형 포인터는 거의 메모리간의 복사를 위한 용도로 사용하는 것이 일반적.
typedef unsigned int size_t;
void* memcpy(void* destination, const void* source, size_t num);
메모리 주소와 관련된 인자를 받는 함수는 대부분 void*형을 많이 사용합니다.
이런 메모리 주소로 작업하는 경우는 대체로 형보단 크기가 중요한 경우이기 때문.
그래서 void*로 주소값을 받고 데이터 길이를 별도 변수로 받는 것.

08 포인터의 사촌 - 배열
각 데이터가 독립적으로 이루어지면 정렬알고리즘도 무용지물이 됩니다. 일일이 비교해서 찾아야 한다.
배열(Array)가 이런 데이터 처리 작업을 편리하게 하기 위한 자료구조 중 하나.
복수 개의 데이터와 이들 데이터간의 유기적인 결합을 통한 데이터 가공을 하기 위해선 자료간에 연관을 지게하고
반복되는 형태의 루프문으로 만들 수 있어야 합니다.
일정된 규칙에 의해 간단한 프로그램응ㄹ 만들어 대용량 데이터처리를 할 수 있는 것이 컴퓨터 특징.
배열은 연속된 메모리 공간을 할당하여 이 각 공간을 인덱스로 액세스할 수 있게 해주는 자료 구조.
중괄호와 함께 원하는 데이터 개수를 적어 선언하게 됩니다.
int math[50];
int english[50];
그럼 메모리엔 각 배열 변수에 대해 50개의 int변수크기만큼 연속된 공간이 잡힙니다.
그리고 메모리 공간은 int단위로 변수 명과 인덱스 값을 통해 액세스할 수 있습니다.
|   |ㄱmath[0] 4bytes   ┐    
|...|...                | 4x50=200바이트
|   |ㄱmath[49] 4bytes  ┘
|   |
|   |ㄱenglish[0] 4bytes  ┐
|...|...                  | 4x50=200바이트
|   |ㄱenglish[49] 4bytes ┘
int 크기인 4바이트 짜리 공간 50개가 연속적으로 할당.
그리고 이 각각의 int공간은 0~49까지의 인덱스를 통해 액세스할 수 있다.
math와 english배열은 서로 아무 연관이 없으며 메모리상에서도 떨어진 곳에 잡히게 된다.
다른 형으로 배열을 잡으면 배열상의 한 원소 크기가 4바이트에서 바뀐다.
중요한 것은 각 원소들이 서로 인접해있고, 인덱스를 통해 액세스가 가능하다는 것.
만약 학생수가 고정이 아니라 입력을 받아야할 경우는 동적으로 메모리를 할당해야하고 액세스하려면 포인터변수.
배열 변수 역시 연속된 메모리 공간의 시작 주소를 나타내고 *연산자처럼 []연산자를 통해 간접 메모리 액세스.
int arrInt[5] = { 0,1,2,3,4 };
int* parrInt = arrInt;
배열 변수를 컴파일러가 int*형의 포인터와 동일시하고 있습니다.
arrInt는 배열의 시작 주소를 나타낸다.
배열은 int형 원소를 갖는 배열이므로 int*형 포인터에 이 주소를 대입할 수 있는 것.
arrInt[0]같이 중괄호로 배열을 액세스하면 인덱스에 해당하는 배열 원소값을 액세스하지만
arrInt라는 배열 변수 자체는 포인터처럼 배열의 시작주소를 나타내는 셈.
arrInt배열 변수 자체에 포인터처럼 값을 더해 나갈 수도 있습니다.
포인터에서 1을 더하면 포인터 형의 사이즈 만큼 더하게 됩니다.
포인터 역시 배열의 액세스 방식을 흉내낼 수 있습니다.
중괄호 연산자가 포인터 변수와 함께 사용될 수 있고, 배열도 *연산자와 함께 사용될 수 있습니다.
|0|ㄱarrInt, parrInt        0 = arrInt[0] = *parrInt = *arrInt = parrInt[0]
|1|ㄱarrInt+1, parrInt+1    1 = arrInt[1] = *(parrInt+1) = *(arrInt+1) = parrInt[1]
|2|ㄱarrInt+2, parrInt+2
|3|ㄱarrInt+3, parrInt+3
|4|ㄱarrInt+4, parrInt+4
결국 배열로 선언되었건 포인터로 선언되었건 액세스할 때 *와 []아무거나 사용 가능.
포인터 변수는 원하는 메모리 주소 어디든지 가리킬 수 있지만, 실질적으로 메모리를 확보할 순 없다.
포인터 변수 자체도 어떤 메모리 주소를 담고 있는 하나의 인스턴스지만 이미 기존에 존재하는
다른 실체 변수인 다른 인스턴스를 가리키기 위한 변수인 것.
int a = 10;
int *pa = &a;
a라는 실체를 가진 변수를 가리키기 위해 pa라는 포인터변수가 쓰일 수는 있어도
가리키는 것만으로 a라는 int변수를 확보할 수는 없다는 얘기.
하지만 배열변수는 arrInt자체가 메모리의 어떤 주소를 가리키는 포인터 역할을 하지만,
선언함으로 인해, 실질적으로 컴파일러가 메모리에서 필요한 메모리를 확보해주어 초기화 가능.
배열로 선언된 변수는 이미 변수 공간을 확보하기 때문에 변수의 개수는 바꿀 수 없습니다.
그리고 배열 변수는 배열로 생성된 메모리 공간 이외의 주소는 가리킬 수 없습니다.
배열 변수에다 포인터 변수 등 다른 값을 대입할 수는 없습니다.
arrInt = parrInt; //에러
결국 배열 변수는 const로 선언된 상수 변수와 마찬가지지만 원소값은 언제든지 바꿀수있다.
arrInt[0]값은 얼마든지 바꿀 수 있지만 arrInt자체를 바꿀 순 없다.

09 포인터와 배열
만약 arrInt배열 변수를 선언하여 5개의 int공간을 확보해 놓고 포인터로 6번째 공간을 읽도록하면 
엉뚱한 값이 읽히지만 쓰도록하면 다른 변수 영역으로 삼은 곳을 침벌할 소지가 있다.
심각하고 디버깅하기 어려운 버그를 발생.
그러므로 스스로 포인터를 사용함에 있어 아주 세심한 주의를 기울여야 한다.

10 다중(다차원) 배열
사실 C에서는 이중 배열이나 삼중배열이니 하는 개념 자체는 없습니다.
배열의 종류는 오직 1차원 배열 뿐. 결국 포인터 형 변수의 포인터.
int arr[100][3]은 항 단위가 int[3]이면서 100개의 원소를 가지는 1차원 배열.
|  |  |  | ... |  |  |  |
└ int[3] ┘     └ int[3] ┘
     └   100개     ┘
void Make_2DArray(int*** array, int row, int col) {
	int i,j;
	*array = malloc(sizeof(int*) * row);
	for (i = 0; i < row; i++) {
		(*array)[i] = malloc(sizeof(int) * col);
	}
	for (i = 0; i < row; i++) {
		for (j = 0; j < col; j++) {
			(*array)[i][j] = 0;
		}
	}
}
함수의 목적은 이중 배열을 동적으로 할당하는 함수.
int arr[100][3] 같이 선언하면 int[3]원소를 100개 가지는 배열이 생성되고 배열의 시작주소를 arr변수가 가리킴.
arr배열은 정적인 변수로 선언이 되고, 컴파일러는 미리 이 변수를 위한 공간을 확보합니다.
하지만 입력에 따라 개수를 지정하려면 동적으로 생성되어야 합니다.
이를 위해 malloc이라는 함수를 통해 힙이라는 메모리 영역에서 동적으로 변수를 할당.
malloc함수를 이용하면 연속된 메모리 공간을 원하는 만큼 할당할 수 있는데
이 malloc을 이용해 2차원 배열 형태로 메모리를 액세스하고자 함수를 작성.
정적인 배열로 선언하지 못하므로 배열 변수와 같은 역할을 하려면 포인터 변수를 이용.
그래서 int arr[100][3]배열도 포인터로 나타낼 수 있는 것.
한 원소는 int가 아닌 int[3]이기때문에 다시 배열 형태.
int*의 포인터인 int**인 것.
한 원소를 나타내기 위한 변수가 int*이므로 결국 (int*)의 포인터형인 int**형 변수로 전체 배열을 나타냄.
int** ppArr = malloc(100*3*4)하면 컴파일 에러가 나진 않습니다. 
1200바이트의 연속된 메모리 공간을 할당받고 시작 주소값을 ppArr변수에 저장.
ppArr은 int*의 포인터 변수이므로 ppArr에 *연산자를 통해 간접 액세스한 값은 다시 int*포인터 변수에 저장.
int* pInt =  *ppInt;하면 쓰레기 값이 출력.
*ppInt의 값을 malloc으로 할당받은 1200바이트의 메모리 중 가장 첫번째 4바이트를 정수로 인식한 값.
따라서 malloc으로 한 번에 1200바이트를 할당하는 것만으로는 ppArr[0]부터 ppArr[299]까지 1차원 배열.
int*는 int형 배열처럼 액세스할 수 있고 ppArr[0]의 값이 실제 int의 배열값을 지니게 된다면,
ppArr은 int배열을 하나의 원소로 하는 배열로 2차원배열이 되는 것.
그러면 (ppArr[0])[0], (ppArr[0])[1], (ppArr[0])[2] 같이 액세스할 수 있게 된다.
그러려면 ppArr[0]의 값이 실제로 존재하는 배열의 주소여야 합니다.
ppArr[0]이 의미있는 값을 가지려면 여기에 다시 malloc을 통해 int배열로 삼을 공간을 할당해야 합니다.
결국 이중 배열을 이중 포인터로 구현하기 위해선 두가지로 나누어 생각해야 합니다.
int arr[100][3]은 int[3]을 한 원소로 하며 100개 늘어서 있는 배열.
arr배열의 원소형인 int[3]역시 int형 변수가 3개 늘어서 있는 또 다른 배열.
int** ppArr = malloc(100*4);
for(int i=0; i < 100; ++i) {
	ppArr[i] = malloc(3*4);
}
int**로 선언된 변수에 int*값 100개를 담을 수 있도록 100*4바이트만큼 할당합니다.
할당된 공간은 ppArr[0]~ppArr[9]로 액세스할 수 있고 각각의 값을 다시 int[3]만큼의 배열 주소를 가리켜야.
따라서 루프를 100개 돌며 각각의 원소를 다시 malloc으로 int크기4와 원소개수3개를 곱한 12만큼할당하여 저장.
int[3]크기의 공간이 메모리상에 100개가 있는데 이 공간들이 반드시 연속일 필요는 없다.
각각 malloc(3*4)로 할당되었고 malloc은 한 번에 할당되는 메모리만을 연속 공간에 할당하고,
매 호출할 때는 할당되는 공간끼리는 연속 할당을 보장하지 않는다.
일반화하려면
int row = 100;
int col = 3;
int** ppArr = malloc(4*row);
for(int i = 0; i < row; ++i) {
	ppArr[i] = malloc(4*col);
}

어셈블리어에서의 변수
고급언어에서는 변수가 선언되면 컴파일러가 내부적으로 선언된 변수 이름과 타입을 기억해 적절한 메모리
위치에 필요한 사이즈만큼을 확보하는 것이고 확보하는 건 컴파일러가 그 공간을 기억한다는 의미로,
이후 다른 변수 선언이 발견되면 컴파일러는 이 공간을 피해 메모리를 확보하고 그 주소를 기억합니다.
하지만 어셈블리어는 이런 개념이 없어 그냥 임의의 메모리 주소에 원하는 값을 저장하고 그 주소값을
직접 필요한 곳에서 다시 사용해서 읽어오는 형식.
문제는 이런 변수에 해당하는 메모리 공간을 선택하는 것이 쉽지 않다.
다행히 어셈블러를 사용하면 메모리 번지를 지정하여 필요한 크기만큼 이름을 붙이고 나중에
그 이름을 참조하면 어셈블러가 주소값을 자동으로 바꿔주는 기능이 있긴하다.
만약 OS와 함께 돌아가야 한다면 OS의 중요한 코드가 메모리의 특정 영역에 자리잡고 있을 수도 있기 때문에
개발자가 임의의 메모리 영역을 선정하면 안됩니다.
재배치라던지 동적 링킹 등으로 복잡한 이슈가 있다.

*/